// This file is generated by /utils/generate_types/index.js
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ChildProcess } from "child_process";
import { EventEmitter } from "events";
import { Readable } from "stream";

/**
 * Can be converted to JSON
 */
type Serializable = {};

type NoHandles<Arg> = Arg extends JSHandle
  ? never
  : Arg extends object
  ? { [Key in keyof Arg]: NoHandles<Arg[Key]> }
  : Arg;
type Unboxed<Arg> = Arg extends ElementHandle<infer T>
  ? T
  : Arg extends JSHandle<infer T>
  ? T
  : Arg extends NoHandles<Arg>
  ? Arg
  : Arg extends Array<infer T>
  ? Array<Unboxed<T>>
  : Arg extends object
  ? { [Key in keyof Arg]: Unboxed<Arg[Key]> }
  : Arg;
type PageFunction<Arg, R> = string | ((arg: Unboxed<Arg>) => R | Promise<R>);
type PageFunctionOn<On, Arg2, R> =
  | string
  | ((on: On, arg2: Unboxed<Arg2>) => R | Promise<R>);
type SmartHandle<T> = T extends Node ? ElementHandle<T> : JSHandle<T>;
type ElementHandleForTag<K extends keyof HTMLElementTagNameMap> = ElementHandle<
  HTMLElementTagNameMap[K]
>;
type HTMLOrSVGElement = SVGElement | HTMLElement;
type HTMLOrSVGElementHandle = ElementHandle<HTMLOrSVGElement>;

type WaitForSelectorOptionsNotHidden = PageWaitForSelectorOptions & {
  waitFor: "visible" | "attached";
};

/**
 * Page provides methods to interact with a single tab in a Browser, or an extension background page in Chromium. One Browser instance might have multiple Page instances.
 * This example creates a page, navigates it to a URL, and then saves a screenshot:
 * ```js
 * const { webkit } = require('playwright');  // Or 'chromium' or 'firefox'.
 *
 * (async () => {
 *   const browser = await webkit.launch();
 *   const context = await browser.newContext();
 *   const page = await context.newPage();
 *   await page.goto('https://example.com');
 *   await page.screenshot({path: 'screenshot.png'});
 *   await browser.close();
 * })();
 * ```
 * The Page class emits various events (described below) which can be handled using any of Node's native `EventEmitter` methods, such as `on`, `once` or `removeListener`.
 * This example logs a message for a single page `load` event:
 * ```js
 * page.once('load', () => console.log('Page loaded!'));
 * ```
 * To unsubscribe from events use the `removeListener` method:
 * ```js
 * function logRequest(interceptedRequest) {
 *   console.log('A request was made:', interceptedRequest.url());
 * }
 * page.on('request', logRequest);
 * // Sometime later...
 * page.removeListener('request', logRequest);
 * ```
 */
export interface Page {
  /**
   * If the function passed to the `page.evaluate` returns a Promise, then `page.evaluate` would wait for the promise to resolve and return its value.
   * If the function passed to the `page.evaluate` returns a non-Serializable value, then `page.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
   * Passing argument to `pageFunction`:
   * ```js
   * const result = await page.evaluate(([x, y]) => {
   *   return Promise.resolve(x * y);
   * }, [7, 8]);
   * console.log(result); // prints "56"
   * ```
   * A string can also be passed in instead of a function:
   * ```js
   * console.log(await page.evaluate('1 + 2')); // prints "3"
   * const x = 10;
   * console.log(await page.evaluate(`1 + ${x}`)); // prints "11"
   * ```
   * ElementHandle instances can be passed as an argument to the `page.evaluate`:
   * ```js
   * const bodyHandle = await page.$('body');
   * const html = await page.evaluate(([body, suffix]) => body.innerHTML + suffix, [bodyHandle, 'hello']);
   * await bodyHandle.dispose();
   * ```
   * Shortcut for page.mainFrame().evaluate(pageFunction[, arg]).
   * @param pageFunction Function to be evaluated in the page context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate<R, Arg>(pageFunction: PageFunction<Arg, R>, arg: Arg): Promise<R>;
  evaluate<R>(pageFunction: PageFunction<void, R>, arg?: any): Promise<R>;

  /**
   * The only difference between `page.evaluate` and `page.evaluateHandle` is that `page.evaluateHandle` returns in-page object (JSHandle).
   * If the function passed to the `page.evaluateHandle` returns a Promise, then `page.evaluateHandle` would wait for the promise to resolve and return its value.
   * A string can also be passed in instead of a function:
   * ```js
   * const aHandle = await page.evaluateHandle('document'); // Handle for the 'document'
   * ```
   * JSHandle instances can be passed as an argument to the `page.evaluateHandle`:
   * ```js
   * const aHandle = await page.evaluateHandle(() => document.body);
   * const resultHandle = await page.evaluateHandle(body => body.innerHTML, aHandle);
   * console.log(await resultHandle.jsonValue());
   * await resultHandle.dispose();
   * ```
   * @param pageFunction Function to be evaluated in the page context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle<R, Arg>(
    pageFunction: PageFunction<Arg, R>,
    arg: Arg
  ): Promise<SmartHandle<R>>;
  evaluateHandle<R>(
    pageFunction: PageFunction<void, R>,
    arg?: any
  ): Promise<SmartHandle<R>>;

  /**
   * The method runs `document.querySelector` within the page. If no element matches the selector, the return value resolves to `null`.
   * Shortcut for page.mainFrame().$(selector).
   * @param selector A selector to query page for
   */
  $<K extends keyof HTMLElementTagNameMap>(
    selector: K
  ): Promise<ElementHandleForTag<K> | null>;
  $(selector: string): Promise<HTMLOrSVGElementHandle | null>;

  /**
   * The method runs `document.querySelectorAll` within the page. If no elements match the selector, the return value resolves to `[]`.
   * Shortcut for page.mainFrame().$$(selector).
   * @param selector A selector to query page for
   */
  $$<K extends keyof HTMLElementTagNameMap>(
    selector: K
  ): Promise<ElementHandleForTag<K>[]>;
  $$(selector: string): Promise<HTMLOrSVGElementHandle[]>;

  /**
   * This method runs `document.querySelector` within the page and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `page.$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const searchValue = await page.$eval('#search', el => el.value);
   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
   * const html = await page.$eval('.main-container', (e, suffix) => e.outerHTML + suffix, 'hello');
   * ```
   * Shortcut for page.mainFrame().$eval(selector, pageFunction).
   * @param selector A selector to query page for
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $eval<K extends keyof HTMLElementTagNameMap, R, Arg>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $eval<R, Arg>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement, Arg, R>,
    arg: Arg
  ): Promise<R>;
  $eval<K extends keyof HTMLElementTagNameMap, R>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K], void, R>,
    arg?: any
  ): Promise<R>;
  $eval<R>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement, void, R>,
    arg?: any
  ): Promise<R>;

  /**
   * This method runs `Array.from(document.querySelectorAll(selector))` within the page and passes it as the first argument to `pageFunction`.
   * If `pageFunction` returns a Promise, then `page.$$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const divsCounts = await page.$$eval('div', (divs, min) => divs.length >= min, 10);
   * ```
   * @param selector A selector to query page for
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $$eval<K extends keyof HTMLElementTagNameMap, R, Arg>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K][], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $$eval<R, Arg>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement[], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $$eval<K extends keyof HTMLElementTagNameMap, R>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K][], void, R>,
    arg?: any
  ): Promise<R>;
  $$eval<R>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement[], void, R>,
    arg?: any
  ): Promise<R>;

  /**
   * The `waitForFunction` can be used to observe viewport size change:
   * ```js
   * const { webkit } = require('playwright');  // Or 'chromium' or 'firefox'.
   *
   * (async () => {
   *   const browser = await webkit.launch();
   *   const page = await browser.newPage();
   *   const watchDog = page.waitForFunction('window.innerWidth < 100');
   *   await page.setViewportSize({width: 50, height: 50});
   *   await watchDog;
   *   await browser.close();
   * })();
   * ```
   * To pass an argument from node.js to the predicate of `page.waitForFunction` function:
   * ```js
   * const selector = '.foo';
   * await page.waitForFunction(selector => !!document.querySelector(selector), selector);
   * ```
   * Shortcut for [page.mainFrame().waitForFunction(pageFunction, arg, options]])](#framewaitforfunctionpagefunction-arg-options).
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @param options Optional waiting parameters
   * @returns Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
   */
  waitForFunction<R, Arg>(
    pageFunction: PageFunction<Arg, R>,
    arg: Arg,
    options?: PageWaitForFunctionOptions
  ): Promise<SmartHandle<R>>;
  waitForFunction<R>(
    pageFunction: PageFunction<void, R>,
    arg?: any,
    options?: PageWaitForFunctionOptions
  ): Promise<SmartHandle<R>>;

  /**
   * Wait for the `selector` to satisfy `waitFor` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn't satisfy the condition for the `timeout` milliseconds, the function will throw.
   * This method works across navigations:
   * ```js
   * const { chromium } = require('playwright');  // Or 'firefox' or 'webkit'.
   *
   * (async () => {
   *   const browser = await chromium.launch();
   *   const page = await browser.newPage();
   *   let currentURL;
   *   page
   *     .waitForSelector('img')
   *     .then(() => console.log('First URL with image: ' + currentURL));
   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {
   *     await page.goto(currentURL);
   *   }
   *   await browser.close();
   * })();
   * ```
   * Shortcut for page.mainFrame().waitForSelector(selector[, options]).
   * @param selector A selector of an element to wait for
   * @param options
   * @returns Promise which resolves when element specified by selector satisfies `waitFor` option. Resolves to `null` if waiting for `hidden` or `detached`.
   */
  waitForSelector<K extends keyof HTMLElementTagNameMap>(
    selector: K,
    options?: WaitForSelectorOptionsNotHidden
  ): Promise<ElementHandleForTag<K>>;
  waitForSelector(
    selector: string,
    options?: WaitForSelectorOptionsNotHidden
  ): Promise<HTMLOrSVGElementHandle>;
  waitForSelector<K extends keyof HTMLElementTagNameMap>(
    selector: K,
    options: PageWaitForSelectorOptions
  ): Promise<ElementHandleForTag<K> | null>;
  waitForSelector(
    selector: string,
    options: PageWaitForSelectorOptions
  ): Promise<null | HTMLOrSVGElementHandle>;
  /**
   * Emitted when the page closes.
   */
  on(event: "close", listener: () => void): this;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  on(
    event: "console",
    listener: (consoleMessage: ConsoleMessage) => void
  ): this;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Playwright can respond to the dialog via Dialog's accept or dismiss methods.
   */
  on(event: "dialog", listener: (dialog: Dialog) => void): this;

  /**
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  on(event: "domcontentloaded", listener: () => void): this;

  /**
   * Emitted when attachment download started. User can access basic file operations on downloaded content via the passed Download instance.
   *
   * **NOTE** Browser context **must** be created with the `acceptDownloads` set to `true` when user needs access to the downloaded content. If `acceptDownloads` is not set or set to `false`, download events are emitted, but the actual download is not performed and user has no access to the downloaded files.
   */
  on(event: "download", listener: (download: Download) => void): this;

  /**
   * Emitted when a file chooser is supposed to appear, such as after clicking the  `<input type=file>`. Playwright can respond to it via setting the input files using `elementHandle.setInputFiles` which can be uploaded in the end.
   * ```js
   * page.on('filechooser', async ({element, multiple}) => {
   *   await element.setInputFiles('/tmp/myfile.pdf');
   * });
   * ```
   */
  on(
    event: "filechooser",
    listener: (pageFilechooserPayload: PageFilechooserPayload) => void
  ): this;

  /**
   * Emitted when a frame is attached.
   */
  on(event: "frameattached", listener: (frame: Frame) => void): this;

  /**
   * Emitted when a frame is detached.
   */
  on(event: "framedetached", listener: (frame: Frame) => void): this;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  on(event: "framenavigated", listener: (frame: Frame) => void): this;

  /**
   * Emitted when the JavaScript `load` event is dispatched.
   */
  on(event: "load", listener: () => void): this;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  on(event: "pageerror", listener: (error: Error) => void): this;

  /**
   * Emitted when the page opens a new tab or window. This event is emitted in addition to the `browserContext.on('page')`, but only for popups relevant to this page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [popup] = await Promise.all([
   *   page.waitForEvent('popup'),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * console.log(await popup.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  on(event: "popup", listener: (page: Page) => void): this;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see !!!`page.route()` or `brows.
   */
  on(event: "request", listener: (request: Request) => void): this;

  /**
   * Emitted when a request fails, for example by timing out.
   *
   * **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request will complete with `'requestfinished'` event and not with `'requestfailed'`.
   */
  on(event: "requestfailed", listener: (request: Request) => void): this;

  /**
   * Emitted when a request finishes successfully.
   */
  on(event: "requestfinished", listener: (request: Request) => void): this;

  /**
   * Emitted when a response is received.
   */
  on(event: "response", listener: (response: Response) => void): this;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  on(event: "worker", listener: (worker: Worker) => void): this;

  /**
   * Emitted when the page closes.
   */
  once(event: "close", listener: () => void): this;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  once(
    event: "console",
    listener: (consoleMessage: ConsoleMessage) => void
  ): this;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Playwright can respond to the dialog via Dialog's accept or dismiss methods.
   */
  once(event: "dialog", listener: (dialog: Dialog) => void): this;

  /**
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  once(event: "domcontentloaded", listener: () => void): this;

  /**
   * Emitted when attachment download started. User can access basic file operations on downloaded content via the passed Download instance.
   *
   * **NOTE** Browser context **must** be created with the `acceptDownloads` set to `true` when user needs access to the downloaded content. If `acceptDownloads` is not set or set to `false`, download events are emitted, but the actual download is not performed and user has no access to the downloaded files.
   */
  once(event: "download", listener: (download: Download) => void): this;

  /**
   * Emitted when a file chooser is supposed to appear, such as after clicking the  `<input type=file>`. Playwright can respond to it via setting the input files using `elementHandle.setInputFiles` which can be uploaded in the end.
   * ```js
   * page.on('filechooser', async ({element, multiple}) => {
   *   await element.setInputFiles('/tmp/myfile.pdf');
   * });
   * ```
   */
  once(
    event: "filechooser",
    listener: (pageFilechooserPayload: PageFilechooserPayload) => void
  ): this;

  /**
   * Emitted when a frame is attached.
   */
  once(event: "frameattached", listener: (frame: Frame) => void): this;

  /**
   * Emitted when a frame is detached.
   */
  once(event: "framedetached", listener: (frame: Frame) => void): this;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  once(event: "framenavigated", listener: (frame: Frame) => void): this;

  /**
   * Emitted when the JavaScript `load` event is dispatched.
   */
  once(event: "load", listener: () => void): this;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  once(event: "pageerror", listener: (error: Error) => void): this;

  /**
   * Emitted when the page opens a new tab or window. This event is emitted in addition to the `browserContext.on('page')`, but only for popups relevant to this page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [popup] = await Promise.all([
   *   page.waitForEvent('popup'),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * console.log(await popup.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  once(event: "popup", listener: (page: Page) => void): this;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see !!!`page.route()` or `brows.
   */
  once(event: "request", listener: (request: Request) => void): this;

  /**
   * Emitted when a request fails, for example by timing out.
   *
   * **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request will complete with `'requestfinished'` event and not with `'requestfailed'`.
   */
  once(event: "requestfailed", listener: (request: Request) => void): this;

  /**
   * Emitted when a request finishes successfully.
   */
  once(event: "requestfinished", listener: (request: Request) => void): this;

  /**
   * Emitted when a response is received.
   */
  once(event: "response", listener: (response: Response) => void): this;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  once(event: "worker", listener: (worker: Worker) => void): this;

  /**
   * Emitted when the page closes.
   */
  addListener(event: "close", listener: () => void): this;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  addListener(
    event: "console",
    listener: (consoleMessage: ConsoleMessage) => void
  ): this;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Playwright can respond to the dialog via Dialog's accept or dismiss methods.
   */
  addListener(event: "dialog", listener: (dialog: Dialog) => void): this;

  /**
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  addListener(event: "domcontentloaded", listener: () => void): this;

  /**
   * Emitted when attachment download started. User can access basic file operations on downloaded content via the passed Download instance.
   *
   * **NOTE** Browser context **must** be created with the `acceptDownloads` set to `true` when user needs access to the downloaded content. If `acceptDownloads` is not set or set to `false`, download events are emitted, but the actual download is not performed and user has no access to the downloaded files.
   */
  addListener(event: "download", listener: (download: Download) => void): this;

  /**
   * Emitted when a file chooser is supposed to appear, such as after clicking the  `<input type=file>`. Playwright can respond to it via setting the input files using `elementHandle.setInputFiles` which can be uploaded in the end.
   * ```js
   * page.on('filechooser', async ({element, multiple}) => {
   *   await element.setInputFiles('/tmp/myfile.pdf');
   * });
   * ```
   */
  addListener(
    event: "filechooser",
    listener: (pageFilechooserPayload: PageFilechooserPayload) => void
  ): this;

  /**
   * Emitted when a frame is attached.
   */
  addListener(event: "frameattached", listener: (frame: Frame) => void): this;

  /**
   * Emitted when a frame is detached.
   */
  addListener(event: "framedetached", listener: (frame: Frame) => void): this;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  addListener(event: "framenavigated", listener: (frame: Frame) => void): this;

  /**
   * Emitted when the JavaScript `load` event is dispatched.
   */
  addListener(event: "load", listener: () => void): this;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  addListener(event: "pageerror", listener: (error: Error) => void): this;

  /**
   * Emitted when the page opens a new tab or window. This event is emitted in addition to the `browserContext.on('page')`, but only for popups relevant to this page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [popup] = await Promise.all([
   *   page.waitForEvent('popup'),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * console.log(await popup.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  addListener(event: "popup", listener: (page: Page) => void): this;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see !!!`page.route()` or `brows.
   */
  addListener(event: "request", listener: (request: Request) => void): this;

  /**
   * Emitted when a request fails, for example by timing out.
   *
   * **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request will complete with `'requestfinished'` event and not with `'requestfailed'`.
   */
  addListener(
    event: "requestfailed",
    listener: (request: Request) => void
  ): this;

  /**
   * Emitted when a request finishes successfully.
   */
  addListener(
    event: "requestfinished",
    listener: (request: Request) => void
  ): this;

  /**
   * Emitted when a response is received.
   */
  addListener(event: "response", listener: (response: Response) => void): this;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  addListener(event: "worker", listener: (worker: Worker) => void): this;

  accessibility: Accessibility;

  /**
   * Adds a script which would be evaluated in one of the following scenarios:
   *
   * Whenever the page is navigated.
   * Whenever the child frame is attached or navigated. In this case, the scritp is evaluated in the context of the newly attached frame.
   *
   * The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
   * An example of overriding `Math.random` before the page loads:
   * ```js
   * // preload.js
   * Math.random = () => 42;
   *
   * // In your playwright script, assuming the preload.js file is in same folder
   * const preloadFile = fs.readFileSync('./preload.js', 'utf8');
   * await page.addInitScript(preloadFile);
   * ```
   *
   * **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.
   * @param script Script to be evaluated in the page.
   * @param arg Optional argument to pass to `script` (only supported when passing a function).
   */
  addInitScript(
    script: Function | string | PageAddInitScriptScript,
    arg?: Serializable
  ): Promise<void>;

  /**
   * Adds a `<script>` tag into the page with the desired url or content.
   * Shortcut for page.mainFrame().addScriptTag(options).
   * @param options
   * @returns which resolves to the added tag when the script's onload fires or when the script content was injected into frame.
   */
  addScriptTag(options: PageAddScriptTagOptions): Promise<ElementHandle>;

  /**
   * Adds a `<link rel="stylesheet">` tag into the page with the desired url or a `<style type="text/css">` tag with the content.
   * Shortcut for page.mainFrame().addStyleTag(options).
   * @param options
   * @returns which resolves to the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.
   */
  addStyleTag(options: PageAddStyleTagOptions): Promise<ElementHandle>;

  /**
   * This method fetches an element with `selector`, if element is not already checked, it scrolls it into view if needed, and then uses page.click to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().check(selector[, options]).
   * @param selector A selector to search for checkbox or radio button to check. If there are multiple elements satisfying the selector, the first will be checked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully checked. The Promise will be rejected if there is no element matching `selector`.
   */
  check(selector: string, options?: PageCheckOptions): Promise<void>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().click(selector[, options]).
   * @param selector A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully clicked. The Promise will be rejected if there is no element matching `selector`.
   */
  click(selector: string, options?: PageClickOptions): Promise<void>;

  /**
   * By default, `page.close()` **does not** run beforeunload handlers.
   *
   * **NOTE** if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned
   * and should be handled manually via page's 'dialog' event.
   * @param options
   */
  close(options?: PageCloseOptions): Promise<void>;

  /**
   * Gets the full HTML contents of the page, including the doctype.
   */
  content(): Promise<string>;

  /**
   * Get the browser context that the page belongs to.
   */
  context(): BrowserContext;

  /**
   * Browser-specific Coverage implementation, only available for Chromium atm. See ChromiumCoverage for more details.
   */
  coverage: null | ChromiumCoverage;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to double click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Bear in mind that if the first click of the `dblclick()` triggers a navigation event, there will be an exception.
   *
   * **NOTE** `page.dblclick()` dispatches two `click` events and a single `dblclick` event.
   *
   * Shortcut for page.mainFrame().dblclick(selector[, options]).
   * @param selector A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully double clicked. The Promise will be rejected if there is no element matching `selector`.
   */
  dblclick(selector: string, options?: PageDblclickOptions): Promise<void>;

  /**
   * ```js
   * await page.evaluate(() => matchMedia('screen').matches));
   * // → true
   * await page.evaluate(() => matchMedia('print').matches));
   * // → true
   *
   * await page.emulateMedia({ media: 'print' });
   * await page.evaluate(() => matchMedia('screen').matches));
   * // → false
   * await page.evaluate(() => matchMedia('print').matches));
   * // → true
   *
   * await page.emulateMedia({});
   * await page.evaluate(() => matchMedia('screen').matches));
   * // → true
   * await page.evaluate(() => matchMedia('print').matches));
   * // → true
   * ```
   * ```js
   * await page.emulateMedia({ colorScheme: 'dark' }] });
   * await page.evaluate(() => matchMedia('(prefers-color-scheme: dark)').matches));
   * // → true
   * await page.evaluate(() => matchMedia('(prefers-color-scheme: light)').matches));
   * // → false
   * await page.evaluate(() => matchMedia('(prefers-color-scheme: no-preference)').matches));
   * // → false
   * ```
   * @param options
   */
  emulateMedia(options: PageEmulateMediaOptions): Promise<void>;

  /**
   * The method adds a function called `name` on the `window` object of every frame in the page.
   * When called, the function executes `playwrightFunction` in node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
   * If the `playwrightFunction` returns a Promise, it will be awaited.
   * See browserContext.exposeFunction(name, playwrightFunction) for context-wide exposed function.
   *
   * **NOTE** Functions installed via `page.exposeFunction` survive navigations.
   *
   * An example of adding an `md5` function to the page:
   * ```js
   * const { webkit } = require('playwright');  // Or 'chromium' or 'firefox'.
   * const crypto = require('crypto');
   *
   * (async () => {
   *   const browser = await webkit.launch({ headless: false });
   *   const page = await browser.newPage();
   *   await page.exposeFunction('md5', text => crypto.createHash('md5').update(text).digest('hex'));
   *   await page.setContent(`
   *     <script>
   *       async function onClick() {
   *         document.querySelector('div').textContent = await window.md5('PLAYWRIGHT');
   *       }
   *     </script>
   *     <button onclick="onClick()">Click me</button>
   *     <div></div>
   *   `);
   *   await page.click('button');
   * })();
   * ```
   * An example of adding a `window.readfile` function to the page:
   * ```js
   * const { chromium } = require('playwright');  // Or 'firefox' or 'webkit'.
   * const fs = require('fs');
   *
   * (async () => {
   *   const browser = await chromium.launch();
   *   const page = await browser.newPage();
   *   page.on('console', msg => console.log(msg.text()));
   *   await page.exposeFunction('readfile', async filePath => {
   *     return new Promise((resolve, reject) => {
   *       fs.readFile(filePath, 'utf8', (err, text) => {
   *         if (err)
   *           reject(err);
   *         else
   *           resolve(text);
   *       });
   *     });
   *   });
   *   await page.evaluate(async () => {
   *     // use window.readfile to read contents of a file
   *     const content = await window.readfile('/etc/hosts');
   *     console.log(content);
   *   });
   *   await browser.close();
   * })();
   * ```
   * @param name Name of the function on the window object
   * @param playwrightFunction Callback function which will be called in Playwright's context.
   */
  exposeFunction(name: string, playwrightFunction: Function): Promise<void>;

  /**
   * This method focuses the element and triggers an `input` event after filling.
   * If there's no text `<input>`, `<textarea>` or `[contenteditable]` element matching `selector`, the method throws an error. Note that you can pass an empty string to clear the input field.
   * To send fine-grained keyboard events, use `page.type`.
   * Shortcut for page.mainFrame().fill()
   * @param selector A selector to query page for.
   * @param value Value to fill for the `<input>`, `<textarea>` or `[contenteditable]` element.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully filled. The promise will be rejected if there is no element matching `selector`.
   */
  fill(
    selector: string,
    value: string,
    options?: PageFillOptions
  ): Promise<void>;

  /**
   * This method fetches an element with `selector` and focuses it.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().focus(selector).
   * @param selector A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully focused. The promise will be rejected if there is no element matching `selector`.
   */
  focus(selector: string, options?: PageFocusOptions): Promise<void>;

  /**
   * ```js
   * const frame = page.frame('frame-name');
   * ```
   * ```js
   * const frame = page.frame({ url: /.*domain.*\/ });
   * ```
   * Returns frame matching the specified criteria. Either `name` or `url` must be specified.
   * @param options Frame name or other frame lookup options.
   * @returns frame matching the criteria. Returns `null` if no frame matches.
   */
  frame(options: string | PageFrameOptions): null | Frame;

  /**
   * @returns An array of all frames attached to the page.
   */
  frames(): Array<Frame>;

  /**
   * Navigate to the previous page in history.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
   * can not go back, resolves to `null`.
   */
  goBack(options?: PageGoBackOptions): Promise<null | Response>;

  /**
   * Navigate to the next page in history.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
   * can not go forward, resolves to `null`.
   */
  goForward(options?: PageGoForwardOptions): Promise<null | Response>;

  /**
   * `page.goto` will throw an error if:
   *
   * there's an SSL error (e.g. in case of self-signed certificates).
   * target URL is invalid.
   * the `timeout` is exceeded during navigation.
   * the remote server does not respond or is unreachable.
   * the main resource failed to load.
   *
   * `page.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 "Not Found" and 500 "Internal Server Error".  The status code for such responses can be retrieved by calling response.status().
   *
   * **NOTE** `page.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
   *
   *
   * **NOTE** Headless mode doesn't support navigation to a PDF document. See the upstream issue.
   *
   * Shortcut for page.mainFrame().goto(url[, options])
   * @param url URL to navigate page to. The url should include scheme, e.g. `https://`.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
   */
  goto(url: string, options?: PageGotoOptions): Promise<null | Response>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to hover over the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().hover(selector[, options]).
   * @param selector A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully hovered. Promise gets rejected if there's no element matching `selector`.
   */
  hover(selector: string, options?: PageHoverOptions): Promise<void>;

  /**
   * Indicates that the page has been closed.
   */
  isClosed(): boolean;

  keyboard: Keyboard;

  /**
   * Page is guaranteed to have a main frame which persists during navigations.
   * @returns The page's main frame.
   */
  mainFrame(): Frame;

  mouse: Mouse;

  /**
   * @returns Promise which resolves to the opener for popup pages and `null` for others. If the opener has been closed already the promise may resolve to `null`.
   */
  opener(): Promise<null | Page>;

  /**
   * **NOTE** Generating a pdf is currently only supported in Chromium headless.
   *
   * `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call page.emulateMedia({ type: 'screen' }) before calling `page.pdf()`:
   *
   * **NOTE** By default, `page.pdf()` generates a pdf with modified colors for printing. Use the `-webkit-print-color-adjust` property to force rendering of exact colors.
   *
   * ```js
   * // Generates a PDF with 'screen' media type.
   * await page.emulateMedia({type: 'screen'});
   * await page.pdf({path: 'page.pdf'});
   * ```
   * The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled values are treated as pixels.
   * A few examples:
   *
   * `page.pdf({width: 100})` - prints with width set to 100 pixels
   * `page.pdf({width: '100px'})` - prints with width set to 100 pixels
   * `page.pdf({width: '10cm'})` - prints with width set to 10 centimeters.
   *
   * All possible units are:
   *
   * `px` - pixel
   * `in` - inch
   * `cm` - centimeter
   * `mm` - millimeter
   *
   * The `format` options are:
   *
   * `Letter`: 8.5in x 11in
   * `Legal`: 8.5in x 14in
   * `Tabloid`: 11in x 17in
   * `Ledger`: 17in x 11in
   * `A0`: 33.1in x 46.8in
   * `A1`: 23.4in x 33.1in
   * `A2`: 16.54in x 23.4in
   * `A3`: 11.7in x 16.54in
   * `A4`: 8.27in x 11.7in
   * `A5`: 5.83in x 8.27in
   * `A6`: 4.13in x 5.83in
   *
   *
   * **NOTE** `headerTemplate` and `footerTemplate` markup have the following limitations:
   *
   * Script tags inside templates are not evaluated.
   * Page styles are not visible inside templates.
   * @param options Options object which might have the following properties:
   * @returns Promise which resolves with PDF buffer.
   */
  pdf(options?: PagePdfOptions): Promise<Buffer>;

  /**
   * Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also be generated. The `text` option can be specified to force an input event to be generated.
   *
   * **NOTE** Modifier keys DO affect `page.press`. Holding down `Shift` will type the text in upper case.
   * @param selector A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   * @param options
   */
  press(
    selector: string,
    key: string,
    options?: PagePressOptions
  ): Promise<void>;

  /**
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
   */
  reload(options?: PageReloadOptions): Promise<null | Response>;

  /**
   * Routing provides the capability to modify network requests that are made by a page.
   * Once routing is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.
   * An example of a naïve handler that aborts all image requests:
   * ```js
   * const page = await browser.newPage();
   * await page.route('**\/*.{png,jpg,jpeg}', route => route.abort());
   * await page.goto('https://example.com');
   * await browser.close();
   * ```
   * or the same snippet using a regex pattern instead:
   * ```js
   * const page = await browser.newPage();
   * await page.route(/(\.png$)|(\.jpg$)/, route => route.abort());
   * await page.goto('https://example.com');
   * await browser.close();
   * ```
   * Page routes take precedence over browser context routes (set up with browserContext.route(url, handler)) when request matches both handlers.
   *
   * **NOTE** Enabling rouing disables http cache.
   * @param url A glob pattern, regex pattern or predicate receiving URL to match while routing.
   * @param handler handler function to route the request.
   * @returns .
   */
  route(
    url: string | RegExp | ((arg0: string) => boolean),
    handler: (arg0: Route, arg1: Request) => void
  ): Promise<void>;

  /**
   * **NOTE** Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See https://crbug.com/741689 for discussion.
   * @param options Options object which might have the following properties:
   * @returns Promise which resolves to buffer with the captured screenshot.
   */
  screenshot(options?: PageScreenshotOptions): Promise<Buffer>;

  /**
   * Triggers a `change` and `input` event once all the provided options have been selected.
   * If there's no `<select>` element matching `selector`, the method throws an error.
   * ```js
   * // single selection matching the value
   * page.selectOption('select#colors', 'blue');
   *
   * // single selection matching both the value and the label
   * page.selectOption('select#colors', { value: 'blue', label: 'Blue' });
   *
   * // multiple selection
   * page.selectOption('select#colors', 'red', 'green', 'blue');
   *
   * // multiple selection for blue, red and second option
   * page.selectOption('select#colors', { value: 'blue' }, { index: 2 }, 'red');
   * ```
   * Shortcut for page.mainFrame().selectOption()
   * @param selector A selector to query frame for.
   * @param values Options to select. If the `<select>` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:'string'}`. Option is considered matching if all specified properties match.
   * @param options
   * @returns An array of option values that have been successfully selected.
   */
  selectOption(
    selector: string,
    values:
      | string
      | ElementHandle
      | Array<string>
      | PageSelectOptionValues
      | Array<ElementHandle>
      | Array<Object>,
    options?: PageSelectOptionOptions
  ): Promise<Array<string>>;

  /**
   * @param html HTML markup to assign to the page.
   * @param options Parameters which might have the following properties:
   */
  setContent(html: string, options?: PageSetContentOptions): Promise<void>;

  /**
   * This setting will change the default maximum navigation time for the following methods and related shortcuts:
   *
   * page.goBack([options])
   * page.goForward([options])
   * page.goto(url[, options])
   * page.reload([options])
   * page.setContent(html[, options])
   * page.waitForNavigation([options])
   *
   *
   * **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`, `browserContext.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout`.
   * @param timeout Maximum navigation time in milliseconds
   */
  setDefaultNavigationTimeout(timeout: number): void;

  /**
   * This setting will change the default maximum time for all the methods accepting `timeout` option.
   *
   * **NOTE** `page.setDefaultNavigationTimeout` takes priority over `page.setDefaultTimeout`.
   * @param timeout Maximum time in milliseconds
   */
  setDefaultTimeout(timeout: number): void;

  /**
   * The extra HTTP headers will be sent with every request the page initiates.
   *
   * **NOTE** page.setExtraHTTPHeaders does not guarantee the order of headers in the outgoing requests.
   * @param headers An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  setExtraHTTPHeaders(headers: Object): Promise<void>;

  /**
   * In the case of multiple pages in a single browser, each page can have its own viewport size. However, browser.newContext([options]) allows to set viewport size (and more) for all pages in the context at once.
   * `page.setViewportSize` will resize the page. A lot of websites don't expect phones to change size, so you should set the viewport size before navigating to the page.
   * ```js
   * const page = await browser.newPage();
   * await page.setViewportSize({
   *   width: 640,
   *   height: 480,
   * });
   * await page.goto('https://example.com');
   * ```
   * @param viewportSize
   */
  setViewportSize(viewportSize: PageSetViewportSizeViewportSize): Promise<void>;

  /**
   * Shortcut for page.mainFrame().title().
   * @returns The page's title.
   */
  title(): Promise<string>;

  /**
   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `page.fill`.
   * To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
   * ```js
   * await page.type('#mytextarea', 'Hello'); // Types instantly
   * await page.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
   * ```
   * Shortcut for page.mainFrame().type(selector, text[, options]).
   * @param selector A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used.
   * @param text A text to type into a focused element.
   * @param options
   */
  type(
    selector: string,
    text: string,
    options?: PageTypeOptions
  ): Promise<void>;

  /**
   * This method fetches an element with `selector`, if element is not already unchecked, it scrolls it into view if needed, and then uses page.click to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().uncheck(selector[, options]).
   * @param selector A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully unchecked. The Promise will be rejected if there is no element matching `selector`.
   */
  uncheck(selector: string, options?: PageUncheckOptions): Promise<void>;

  /**
   * This is a shortcut for page.mainFrame().url()
   */
  url(): string;

  viewportSize(): null | PageViewportSize;

  /**
   * This method behaves differently with respect to the type of the first parameter:
   *
   * if `selectorOrFunctionOrTimeout` is a `string`, then the first argument is treated as a selector and the method is a shortcut for page.waitForSelector
   * if `selectorOrFunctionOrTimeout` is a `function`, then the first argument is treated as a predicate to wait for and the method is a shortcut for page.waitForFunction().
   * if `selectorOrFunctionOrTimeout` is a `number`, then the first argument is treated as a timeout in milliseconds and the method returns a promise which resolves after the timeout
   * otherwise, an exception is thrown
   *
   * ```js
   * // wait for selector
   * await page.waitFor('.foo');
   * // wait for 1 second
   * await page.waitFor(1000);
   * // wait for predicate
   * await page.waitFor(() => !!document.querySelector('.foo'));
   * ```
   * To pass an argument from node.js to the predicate of `page.waitFor` function:
   * ```js
   * const selector = '.foo';
   * await page.waitFor(selector => !!document.querySelector(selector), {}, selector);
   * ```
   * Shortcut for page.mainFrame().waitFor(selectorOrFunctionOrTimeout[, options[, ...args]]).
   * @param selectorOrFunctionOrTimeout A selector, predicate or timeout to wait for
   * @param options Optional waiting parameters
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to a JSHandle of the success value
   */
  waitFor(
    selectorOrFunctionOrTimeout: string | number | Function,
    options?: PageWaitForOptions,
    arg?: Serializable | JSHandle
  ): Promise<null | JSHandle>;

  /**
   * Emitted when the page closes.
   */
  waitForEvent(
    event: "close",
    optionsOrPredicate?: { predicate?: () => boolean; timeout?: number }
  ): Promise<void>;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  waitForEvent(
    event: "console",
    optionsOrPredicate?: {
      predicate?: (consoleMessage: ConsoleMessage) => boolean;
      timeout?: number;
    }
  ): Promise<ConsoleMessage>;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Playwright can respond to the dialog via Dialog's accept or dismiss methods.
   */
  waitForEvent(
    event: "dialog",
    optionsOrPredicate?: {
      predicate?: (dialog: Dialog) => boolean;
      timeout?: number;
    }
  ): Promise<Dialog>;

  /**
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  waitForEvent(
    event: "domcontentloaded",
    optionsOrPredicate?: { predicate?: () => boolean; timeout?: number }
  ): Promise<void>;

  /**
   * Emitted when attachment download started. User can access basic file operations on downloaded content via the passed Download instance.
   *
   * **NOTE** Browser context **must** be created with the `acceptDownloads` set to `true` when user needs access to the downloaded content. If `acceptDownloads` is not set or set to `false`, download events are emitted, but the actual download is not performed and user has no access to the downloaded files.
   */
  waitForEvent(
    event: "download",
    optionsOrPredicate?: {
      predicate?: (download: Download) => boolean;
      timeout?: number;
    }
  ): Promise<Download>;

  /**
   * Emitted when a file chooser is supposed to appear, such as after clicking the  `<input type=file>`. Playwright can respond to it via setting the input files using `elementHandle.setInputFiles` which can be uploaded in the end.
   * ```js
   * page.on('filechooser', async ({element, multiple}) => {
   *   await element.setInputFiles('/tmp/myfile.pdf');
   * });
   * ```
   */
  waitForEvent(
    event: "filechooser",
    optionsOrPredicate?: {
      predicate?: (pageFilechooserPayload: PageFilechooserPayload) => boolean;
      timeout?: number;
    }
  ): Promise<PageFilechooserPayload>;

  /**
   * Emitted when a frame is attached.
   */
  waitForEvent(
    event: "frameattached",
    optionsOrPredicate?: {
      predicate?: (frame: Frame) => boolean;
      timeout?: number;
    }
  ): Promise<Frame>;

  /**
   * Emitted when a frame is detached.
   */
  waitForEvent(
    event: "framedetached",
    optionsOrPredicate?: {
      predicate?: (frame: Frame) => boolean;
      timeout?: number;
    }
  ): Promise<Frame>;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  waitForEvent(
    event: "framenavigated",
    optionsOrPredicate?: {
      predicate?: (frame: Frame) => boolean;
      timeout?: number;
    }
  ): Promise<Frame>;

  /**
   * Emitted when the JavaScript `load` event is dispatched.
   */
  waitForEvent(
    event: "load",
    optionsOrPredicate?: { predicate?: () => boolean; timeout?: number }
  ): Promise<void>;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  waitForEvent(
    event: "pageerror",
    optionsOrPredicate?: {
      predicate?: (error: Error) => boolean;
      timeout?: number;
    }
  ): Promise<Error>;

  /**
   * Emitted when the page opens a new tab or window. This event is emitted in addition to the `browserContext.on('page')`, but only for popups relevant to this page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [popup] = await Promise.all([
   *   page.waitForEvent('popup'),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * console.log(await popup.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  waitForEvent(
    event: "popup",
    optionsOrPredicate?: {
      predicate?: (page: Page) => boolean;
      timeout?: number;
    }
  ): Promise<Page>;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see !!!`page.route()` or `brows.
   */
  waitForEvent(
    event: "request",
    optionsOrPredicate?: {
      predicate?: (request: Request) => boolean;
      timeout?: number;
    }
  ): Promise<Request>;

  /**
   * Emitted when a request fails, for example by timing out.
   *
   * **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request will complete with `'requestfinished'` event and not with `'requestfailed'`.
   */
  waitForEvent(
    event: "requestfailed",
    optionsOrPredicate?: {
      predicate?: (request: Request) => boolean;
      timeout?: number;
    }
  ): Promise<Request>;

  /**
   * Emitted when a request finishes successfully.
   */
  waitForEvent(
    event: "requestfinished",
    optionsOrPredicate?: {
      predicate?: (request: Request) => boolean;
      timeout?: number;
    }
  ): Promise<Request>;

  /**
   * Emitted when a response is received.
   */
  waitForEvent(
    event: "response",
    optionsOrPredicate?: {
      predicate?: (response: Response) => boolean;
      timeout?: number;
    }
  ): Promise<Response>;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  waitForEvent(
    event: "worker",
    optionsOrPredicate?: {
      predicate?: (worker: Worker) => boolean;
      timeout?: number;
    }
  ): Promise<Worker>;

  /**
   * This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.
   * ```js
   * await page.click('button'); // Click triggers navigation.
   * await page.waitForLoadState(); // The promise resolves after 'load' event.
   * ```
   * ```js
   * const [popup] = await Promise.all([
   *   page.waitForEvent('popup'),
   *   page.click('button'), // Click triggers a popup.
   * ])
   * await popup.waitForLoadState('domcontentloaded'); // The promise resolves after 'domcontentloaded' event.
   * console.log(await popup.title()); // Popup is ready to use.
   * ```
   * Shortcut for page.mainFrame().waitForLoadState([options]).
   * @param state Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.  - `'load'` - wait for the `load` event to be fired.
   *  - `'domcontentloaded'` - wait for the `DOMContentLoaded` event to be fired.
   *  - `'networkidle0'` - wait until there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - wait until there are no more than 2 network connections for at least `500` ms.
   * @param options
   * @returns Promise which resolves when the required load state has been reached.
   */
  waitForLoadState(
    state?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2",
    options?: PageWaitForLoadStateOptions
  ): Promise<void>;

  /**
   * This resolves when the page navigates to a new URL or reloads. It is useful for when you run code
   * which will indirectly cause the page to navigate. Consider this example:
   * ```js
   * const [response] = await Promise.all([
   *   page.waitForNavigation(), // The promise resolves after navigation has finished
   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
   * ]);
   * ```
   * **NOTE** Usage of the History API to change the URL is considered a navigation.
   * Shortcut for page.mainFrame().waitForNavigation(options).
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
   */
  waitForNavigation(
    options?: PageWaitForNavigationOptions
  ): Promise<null | Response>;

  /**
   * ```js
   * const firstRequest = await page.waitForRequest('http://example.com/resource');
   * const finalRequest = await page.waitForRequest(request => request.url() === 'http://example.com' && request.method() === 'GET');
   * return firstRequest.url();
   * ```
   * ```js
   * await page.waitForRequest(request => request.url().searchParams.get('foo') === 'bar' && request.url().searchParams.get('foo2') === 'bar2');
   * ```
   * @param urlOrPredicate Request URL string, regex or predicate receiving Request object.
   * @param options Optional waiting parameters
   * @returns Promise which resolves to the matched request.
   */
  waitForRequest(
    urlOrPredicate: string | RegExp | Function,
    options?: PageWaitForRequestOptions
  ): Promise<Request>;

  /**
   * ```js
   * const firstResponse = await page.waitForResponse('https://example.com/resource');
   * const finalResponse = await page.waitForResponse(response => response.url() === 'https://example.com' && response.status() === 200);
   * return finalResponse.ok();
   * ```
   * @param urlOrPredicate Request URL string, regex or predicate receiving Response object.
   * @param options Optional waiting parameters
   * @returns Promise which resolves to the matched response.
   */
  waitForResponse(
    urlOrPredicate: string | RegExp | Function,
    options?: PageWaitForResponseOptions
  ): Promise<Response>;

  /**
   * **NOTE** This does not contain ServiceWorkers
   * @returns This method returns all of the dedicated WebWorkers associated with the page.
   */
  workers(): Array<Worker>;
}

/**
 * At every point of time, page exposes its current frame tree via the page.mainFrame() and frame.childFrames() methods.
 * Frame object's lifecycle is controlled by three events, dispatched on the page object:
 *
 * 'frameattached' - fired when the frame gets attached to the page. A Frame can be attached to the page only once.
 * 'framenavigated' - fired when the frame commits navigation to a different URL.
 * 'framedetached' - fired when the frame gets detached from the page.  A Frame can be detached from the page only once.
 *
 * An example of dumping frame tree:
 * ```js
 * const { firefox } = require('playwright');  // Or 'chromium' or 'webkit'.
 *
 * (async () => {
 *   const browser = await firefox.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://www.google.com/chrome/browser/canary.html');
 *   dumpFrameTree(page.mainFrame(), '');
 *   await browser.close();
 *
 *   function dumpFrameTree(frame, indent) {
 *     console.log(indent + frame.url());
 *     for (const child of frame.childFrames()) {
 *       dumpFrameTree(child, indent + '  ');
 *     }
 *   }
 * })();
 * ```
 * An example of getting text from an iframe element:
 * ```js
 *   const frame = page.frames().find(frame => frame.name() === 'myframe');
 *   const text = await frame.$eval('.selector', element => element.textContent);
 *   console.log(text);
 * ```
 */
export interface Frame {
  /**
   * If the function passed to the `frame.evaluate` returns a Promise, then `frame.evaluate` would wait for the promise to resolve and return its value.
   * If the function passed to the `frame.evaluate` returns a non-Serializable value, then `frame.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
   * ```js
   * const result = await frame.evaluate(([x, y]) => {
   *   return Promise.resolve(x * y);
   * }, [7, 8]);
   * console.log(result); // prints "56"
   * ```
   * A string can also be passed in instead of a function.
   * ```js
   * console.log(await frame.evaluate('1 + 2')); // prints "3"
   * ```
   * ElementHandle instances can be passed as an argument to the `frame.evaluate`:
   * ```js
   * const bodyHandle = await frame.$('body');
   * const html = await frame.evaluate(([body, suffix]) => body.innerHTML + suffix, [bodyHandle, 'hello']);
   * await bodyHandle.dispose();
   * ```
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate<R, Arg>(pageFunction: PageFunction<Arg, R>, arg: Arg): Promise<R>;
  evaluate<R>(pageFunction: PageFunction<void, R>, arg?: any): Promise<R>;

  /**
   * The only difference between `frame.evaluate` and `frame.evaluateHandle` is that `frame.evaluateHandle` returns in-page object (JSHandle).
   * If the function, passed to the `frame.evaluateHandle`, returns a Promise, then `frame.evaluateHandle` would wait for the promise to resolve and return its value.
   * ```js
   * const aWindowHandle = await frame.evaluateHandle(() => Promise.resolve(window));
   * aWindowHandle; // Handle for the window object.
   * ```
   * A string can also be passed in instead of a function.
   * ```js
   * const aHandle = await frame.evaluateHandle('document'); // Handle for the 'document'.
   * ```
   * JSHandle instances can be passed as an argument to the `frame.evaluateHandle`:
   * ```js
   * const aHandle = await frame.evaluateHandle(() => document.body);
   * const resultHandle = await frame.evaluateHandle(([body, suffix]) => body.innerHTML + suffix, [aHandle, 'hello']);
   * console.log(await resultHandle.jsonValue());
   * await resultHandle.dispose();
   * ```
   * @param pageFunction Function to be evaluated in the page context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle<R, Arg>(
    pageFunction: PageFunction<Arg, R>,
    arg: Arg
  ): Promise<SmartHandle<R>>;
  evaluateHandle<R>(
    pageFunction: PageFunction<void, R>,
    arg?: any
  ): Promise<SmartHandle<R>>;

  /**
   * The method queries frame for the selector. If there's no such element within the frame, the method will resolve to `null`.
   * @param selector A selector to query frame for
   * @returns Promise which resolves to ElementHandle pointing to the frame element.
   */
  $<K extends keyof HTMLElementTagNameMap>(
    selector: K
  ): Promise<ElementHandleForTag<K> | null>;
  $(selector: string): Promise<HTMLOrSVGElementHandle | null>;

  /**
   * The method runs `document.querySelectorAll` within the frame. If no elements match the selector, the return value resolves to `[]`.
   * @param selector A selector to query frame for
   * @returns Promise which resolves to ElementHandles pointing to the frame elements.
   */
  $$<K extends keyof HTMLElementTagNameMap>(
    selector: K
  ): Promise<ElementHandleForTag<K>[]>;
  $$(selector: string): Promise<HTMLOrSVGElementHandle[]>;

  /**
   * This method runs `document.querySelector` within the frame and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const searchValue = await frame.$eval('#search', el => el.value);
   * const preloadHref = await frame.$eval('link[rel=preload]', el => el.href);
   * const html = await frame.$eval('.main-container', (e, suffix) => e.outerHTML + suffix, 'hello');
   * ```
   * @param selector A selector to query frame for
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $eval<K extends keyof HTMLElementTagNameMap, R, Arg>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $eval<R, Arg>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement, Arg, R>,
    arg: Arg
  ): Promise<R>;
  $eval<K extends keyof HTMLElementTagNameMap, R>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K], void, R>,
    arg?: any
  ): Promise<R>;
  $eval<R>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement, void, R>,
    arg?: any
  ): Promise<R>;

  /**
   * This method runs `Array.from(document.querySelectorAll(selector))` within the frame and passes it as the first argument to `pageFunction`.
   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const divsCounts = await frame.$$eval('div', (divs, min) => divs.length >= min, 10);
   * ```
   * @param selector A selector to query frame for
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $$eval<K extends keyof HTMLElementTagNameMap, R, Arg>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K][], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $$eval<R, Arg>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement[], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $$eval<K extends keyof HTMLElementTagNameMap, R>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K][], void, R>,
    arg?: any
  ): Promise<R>;
  $$eval<R>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement[], void, R>,
    arg?: any
  ): Promise<R>;

  /**
   * The `waitForFunction` can be used to observe viewport size change:
   * ```js
   * const { firefox } = require('playwright');  // Or 'chromium' or 'webkit'.
   *
   * (async () => {
   *   const browser = await firefox.launch();
   *   const page = await browser.newPage();
   *   const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
   *   page.setViewportSize({width: 50, height: 50});
   *   await watchDog;
   *   await browser.close();
   * })();
   * ```
   * To pass an argument from node.js to the predicate of `frame.waitForFunction` function:
   * ```js
   * const selector = '.foo';
   * await frame.waitForFunction(selector => !!document.querySelector(selector), selector);
   * ```
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @param options Optional waiting parameters
   * @returns Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
   */
  waitForFunction<R, Arg>(
    pageFunction: PageFunction<Arg, R>,
    arg: Arg,
    options?: PageWaitForFunctionOptions
  ): Promise<SmartHandle<R>>;
  waitForFunction<R>(
    pageFunction: PageFunction<void, R>,
    arg?: any,
    options?: PageWaitForFunctionOptions
  ): Promise<SmartHandle<R>>;

  /**
   * Wait for the `selector` to satisfy `waitFor` option (either appear/disappear from dom, or become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the selector doesn't satisfy the condition for the `timeout` milliseconds, the function will throw.
   * This method works across navigations:
   * ```js
   * const { webkit } = require('playwright');  // Or 'chromium' or 'firefox'.
   *
   * (async () => {
   *   const browser = await webkit.launch();
   *   const page = await browser.newPage();
   *   let currentURL;
   *   page.mainFrame()
   *     .waitForSelector('img')
   *     .then(() => console.log('First URL with image: ' + currentURL));
   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {
   *     await page.goto(currentURL);
   *   }
   *   await browser.close();
   * })();
   * ```
   * @param selector A selector of an element to wait for
   * @param options
   * @returns Promise which resolves when element specified by selector satisfies `waitFor` option. Resolves to `null` if waiting for `hidden` or `detached`.
   */
  waitForSelector<K extends keyof HTMLElementTagNameMap>(
    selector: K,
    options?: WaitForSelectorOptionsNotHidden
  ): Promise<ElementHandleForTag<K>>;
  waitForSelector(
    selector: string,
    options?: WaitForSelectorOptionsNotHidden
  ): Promise<HTMLOrSVGElementHandle>;
  waitForSelector<K extends keyof HTMLElementTagNameMap>(
    selector: K,
    options: PageWaitForSelectorOptions
  ): Promise<ElementHandleForTag<K> | null>;
  waitForSelector(
    selector: string,
    options: PageWaitForSelectorOptions
  ): Promise<null | HTMLOrSVGElementHandle>;
  /**
   * Adds a `<script>` tag into the page with the desired url or content.
   * @param options
   * @returns which resolves to the added tag when the script's onload fires or when the script content was injected into frame.
   */
  addScriptTag(options: FrameAddScriptTagOptions): Promise<ElementHandle>;

  /**
   * Adds a `<link rel="stylesheet">` tag into the page with the desired url or a `<style type="text/css">` tag with the content.
   * @param options
   * @returns which resolves to the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.
   */
  addStyleTag(options: FrameAddStyleTagOptions): Promise<ElementHandle>;

  /**
   * This method fetches an element with `selector`, if element is not already checked, it scrolls it into view if needed, and then uses frame.click to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector to search for checkbox to check. If there are multiple elements satisfying the selector, the first will be checked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully checked. The Promise will be rejected if there is no element matching `selector`.
   */
  check(selector: string, options?: FrameCheckOptions): Promise<void>;

  childFrames(): Array<Frame>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully clicked. The Promise will be rejected if there is no element matching `selector`.
   */
  click(selector: string, options?: FrameClickOptions): Promise<void>;

  /**
   * Gets the full HTML contents of the frame, including the doctype.
   */
  content(): Promise<string>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to double click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Bear in mind that if the first click of the `dblclick()` triggers a navigation event, there will be an exception.
   *
   * **NOTE** `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.
   * @param selector A selector to search for element to double click. If there are multiple elements satisfying the selector, the first will be double clicked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully double clicked. The Promise will be rejected if there is no element matching `selector`.
   */
  dblclick(selector: string, options?: FrameDblclickOptions): Promise<void>;

  /**
   * This method focuses the element and triggers an `input` event after filling.
   * If there's no text `<input>`, `<textarea>` or `[contenteditable]` element matching `selector`, the method throws an error.
   * To send fine-grained keyboard events, use `frame.type`.
   * @param selector A selector to query page for.
   * @param value Value to fill for the `<input>`, `<textarea>` or `[contenteditable]` element.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully filled. The promise will be rejected if there is no element matching `selector`.
   */
  fill(
    selector: string,
    value: string,
    options?: FrameFillOptions
  ): Promise<void>;

  /**
   * This method fetches an element with `selector` and focuses it.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully focused. The promise will be rejected if there is no element matching `selector`.
   */
  focus(selector: string, options?: FrameFocusOptions): Promise<void>;

  /**
   * This is an inverse of elementHandle.contentFrame(). Note that returned handle actually belongs to the parent frame.
   * This method throws an error if the frame has been detached before `frameElement()` returns.
   * ```js
   * const frameElement = await frame.frameElement();
   * const contentFrame = await frameElement.contentFrame();
   * console.log(frame === contentFrame);  // -> true
   * ```
   * @returns Promise that resolves with a `frame` or `iframe` element handle which corresponds to this frame.
   */
  frameElement(): Promise<ElementHandle>;

  /**
   * `frame.goto` will throw an error if:
   *
   * there's an SSL error (e.g. in case of self-signed certificates).
   * target URL is invalid.
   * the `timeout` is exceeded during navigation.
   * the remote server does not respond or is unreachable.
   * the main resource failed to load.
   *
   * `frame.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 "Not Found" and 500 "Internal Server Error".  The status code for such responses can be retrieved by calling response.status().
   *
   * **NOTE** `frame.goto` either throws an error or returns a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
   *
   *
   * **NOTE** Headless mode doesn't support navigation to a PDF document. See the upstream issue.
   * @param url URL to navigate frame to. The url should include scheme, e.g. `https://`.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
   */
  goto(url: string, options?: FrameGotoOptions): Promise<null | Response>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to hover over the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully hovered. Promise gets rejected if there's no element matching `selector`.
   */
  hover(selector: string, options?: FrameHoverOptions): Promise<void>;

  /**
   * Returns `true` if the frame has been detached, or `false` otherwise.
   */
  isDetached(): boolean;

  /**
   * Returns frame's name attribute as specified in the tag.
   * If the name is empty, returns the id attribute instead.
   *
   * **NOTE** This value is calculated once when the frame is created, and will not update if the attribute is changed later.
   */
  name(): string;

  /**
   * @returns Parent frame, if any. Detached frames and main frames return `null`.
   */
  parentFrame(): null | Frame;

  /**
   * Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also be generated. The `text` option can be specified to force an input event to be generated.
   *
   * **NOTE** Modifier keys DO affect `frame.press`. Holding down `Shift` will type the text in upper case.
   * @param selector A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   * @param options
   */
  press(
    selector: string,
    key: string,
    options?: FramePressOptions
  ): Promise<void>;

  /**
   * Triggers a `change` and `input` event once all the provided options have been selected.
   * If there's no `<select>` element matching `selector`, the method throws an error.
   * ```js
   * // single selection matching the value
   * frame.selectOption('select#colors', 'blue');
   *
   * // single selection matching both the value and the label
   * frame.selectOption('select#colors', { value: 'blue', label: 'Blue' });
   *
   * // multiple selection
   * frame.selectOption('select#colors', 'red', 'green', 'blue');
   *
   * // multiple selection matching blue, red and second option
   * frame.selectOption('select#colors', { value: 'blue' }, { index: 2 }, 'red');
   * ```
   * @param selector A selector to query frame for.
   * @param values Options to select. If the `<select>` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:'string'}`. Option is considered matching if all specified properties match.
   * @param options
   * @returns An array of option values that have been successfully selected.
   */
  selectOption(
    selector: string,
    values:
      | string
      | ElementHandle
      | Array<string>
      | FrameSelectOptionValues
      | Array<ElementHandle>
      | Array<Object>,
    options?: FrameSelectOptionOptions
  ): Promise<Array<string>>;

  /**
   * @param html HTML markup to assign to the page.
   * @param options Parameters which might have the following properties:
   */
  setContent(html: string, options?: FrameSetContentOptions): Promise<void>;

  /**
   * @returns The page's title.
   */
  title(): Promise<string>;

  /**
   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used to send fine-grained keyboard events. To fill values in form fields, use `frame.fill`.
   * To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
   * ```js
   * await frame.type('#mytextarea', 'Hello'); // Types instantly
   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
   * ```
   * @param selector A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used.
   * @param text A text to type into a focused element.
   * @param options
   */
  type(
    selector: string,
    text: string,
    options?: FrameTypeOptions
  ): Promise<void>;

  /**
   * This method fetches an element with `selector`, if element is not already unchecked, it scrolls it into view if needed, and then uses frame.click to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector to search for uncheckbox to check. If there are multiple elements satisfying the selector, the first will be checked.
   * @param options
   * @returns Promise which resolves when the element matching `selector` is successfully unchecked. The Promise will be rejected if there is no element matching `selector`.
   */
  uncheck(selector: string, options?: FrameUncheckOptions): Promise<void>;

  /**
   * Returns frame's url.
   */
  url(): string;

  /**
   * This method behaves differently with respect to the type of the first parameter:
   *
   * if `selectorOrFunctionOrTimeout` is a `string`, then the first argument is treated as a selector and the method is a shortcut for frame.waitForSelector
   * if `selectorOrFunctionOrTimeout` is a `function`, then the first argument is treated as a predicate to wait for and the method is a shortcut for frame.waitForFunction().
   * if `selectorOrFunctionOrTimeout` is a `number`, then the first argument is treated as a timeout in milliseconds and the method returns a promise which resolves after the timeout
   * otherwise, an exception is thrown
   *
   * ```js
   * // wait for selector
   * await frame.waitFor('.foo');
   * // wait for 1 second
   * await frame.waitFor(1000);
   * // wait for predicate
   * await frame.waitFor(() => !!document.querySelector('.foo'));
   * ```
   * To pass an argument from node.js to the predicate of `frame.waitFor` function:
   * ```js
   * const selector = '.foo';
   * await frame.waitFor(selector => !!document.querySelector(selector), {}, selector);
   * ```
   * @param selectorOrFunctionOrTimeout A selector, predicate or timeout to wait for
   * @param options Optional waiting parameters
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to a JSHandle of the success value
   */
  waitFor(
    selectorOrFunctionOrTimeout: string | number | Function,
    options?: FrameWaitForOptions,
    arg?: Serializable | JSHandle
  ): Promise<null | JSHandle>;

  /**
   * This resolves when the frame reaches a required load state, `load` by default. The navigation must have been committed when this method is called. If current document has already reached the required state, resolves immediately.
   * ```js
   * await frame.click('button'); // Click triggers navigation.
   * await frame.waitForLoadState(); // The promise resolves after 'load' event.
   * ```
   * @param state Load state to wait for, defaults to `load`. If the state has been already reached while loading current document, the method resolves immediately.  - `'load'` - wait for the `load` event to be fired.
   *  - `'domcontentloaded'` - wait for the `DOMContentLoaded` event to be fired.
   *  - `'networkidle0'` - wait until there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - wait until there are no more than 2 network connections for at least `500` ms.
   * @param options
   * @returns Promise which resolves when the required load state has been reached.
   */
  waitForLoadState(
    state?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2",
    options?: FrameWaitForLoadStateOptions
  ): Promise<void>;

  /**
   * This resolves when the frame navigates to a new URL. It is useful for when you run code
   * which will indirectly cause the frame to navigate. Consider this example:
   * ```js
   * const [response] = await Promise.all([
   *   frame.waitForNavigation(), // The navigation promise resolves after navigation has finished
   *   frame.click('a.my-link'), // Clicking the link will indirectly cause a navigation
   * ]);
   * ```
   * **NOTE** Usage of the History API to change the URL is considered a navigation.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
   */
  waitForNavigation(
    options?: FrameWaitForNavigationOptions
  ): Promise<null | Response>;
}

/**
 * The Worker class represents a WebWorker.
 * `worker` event is emitted on the page object to signal a worker creation.
 * `close` event is emitted on the worker object when the worker is gone.
 * ```js
 * page.on('worker', worker => {
 *   console.log('Worker created: ' + worker.url());
 *   worker.on('close', worker => console.log('Worker destroyed: ' + worker.url()));
 * });
 *
 * console.log('Current workers:');
 * for (const worker of page.workers())
 *   console.log('  ' + worker.url());
 * ```
 */
export interface Worker {
  /**
   * If the function passed to the `worker.evaluate` returns a Promise, then `worker.evaluate` would wait for the promise to resolve and return its value.
   * If the function passed to the `worker.evaluate` returns a non-Serializable value, then `worker.evaluate` resolves to `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.
   * @param pageFunction Function to be evaluated in the worker context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate<R, Arg>(pageFunction: PageFunction<Arg, R>, arg: Arg): Promise<R>;
  evaluate<R>(pageFunction: PageFunction<void, R>, arg?: any): Promise<R>;

  /**
   * The only difference between `worker.evaluate` and `worker.evaluateHandle` is that `worker.evaluateHandle` returns in-page object (JSHandle).
   * If the function passed to the `worker.evaluateHandle` returns a Promise, then `worker.evaluateHandle` would wait for the promise to resolve and return its value.
   * @param pageFunction Function to be evaluated in the page context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle<R, Arg>(
    pageFunction: PageFunction<Arg, R>,
    arg: Arg
  ): Promise<SmartHandle<R>>;
  evaluateHandle<R>(
    pageFunction: PageFunction<void, R>,
    arg?: any
  ): Promise<SmartHandle<R>>;
  /**
   * Emitted when this dedicated WebWorker is terminated.
   */
  on(event: "close", listener: (worker: Worker) => void): this;

  /**
   * Emitted when this dedicated WebWorker is terminated.
   */
  once(event: "close", listener: (worker: Worker) => void): this;

  /**
   * Emitted when this dedicated WebWorker is terminated.
   */
  addListener(event: "close", listener: (worker: Worker) => void): this;

  url(): string;
}

/**
 * JSHandle represents an in-page JavaScript object. JSHandles can be created with the page.evaluateHandle method.
 * ```js
 * const windowHandle = await page.evaluateHandle(() => window);
 * // ...
 * ```
 * JSHandle prevents the referenced JavaScript object being garbage collected unless the handle is disposed. JSHandles are auto-disposed when their origin frame gets navigated or the parent context gets destroyed.
 * JSHandle instances can be used as an argument in `page.$eval()`, `page.evaluate()` and `page.evaluateHandle()` methods.
 */
export interface JSHandle<T = any> {
  /**
   * This method passes this handle as the first argument to `pageFunction`.
   * If `pageFunction` returns a Promise, then `handle.evaluate` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const tweetHandle = await page.$('.tweet .retweets');
   * expect(await tweetHandle.evaluate((node, suffix) => node.innerText, ' retweets')).toBe('10 retweets');
   * ```
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate<R, Arg>(
    pageFunction: PageFunctionOn<T, Arg, R>,
    arg: Arg
  ): Promise<R>;
  evaluate<R>(pageFunction: PageFunctionOn<T, void, R>, arg?: any): Promise<R>;

  /**
   * This method passes this handle as the first argument to `pageFunction`.
   * The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle` returns in-page object (JSHandle).
   * If the function passed to the `jsHandle.evaluateHandle` returns a Promise, then `jsHandle.evaluateHandle` would wait for the promise to resolve and return its value.
   * See page.evaluateHandle() for more details.
   * @param pageFunction Function to be evaluated
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle<R, Arg>(
    pageFunction: PageFunctionOn<T, Arg, R>,
    arg: Arg
  ): Promise<SmartHandle<R>>;
  evaluateHandle<R>(
    pageFunction: PageFunctionOn<T, void, R>,
    arg?: any
  ): Promise<SmartHandle<R>>;

  /**
   * Returns a JSON representation of the object. If the object has a
   * `toJSON`
   * function, it **will not be called**.
   *
   * **NOTE** The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an error if the object has circular references.
   */
  jsonValue(): Promise<T>;
  /**
   * Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.
   */
  asElement(): T extends Node ? ElementHandle<T> : null;
  /**
   * The `jsHandle.dispose` method stops referencing the element handle.
   * @returns Promise which resolves when the object handle is successfully disposed.
   */
  dispose(): Promise<void>;

  /**
   * The method returns a map with **own property names** as keys and JSHandle instances for the property values.
   * ```js
   * const handle = await page.evaluateHandle(() => ({window, document}));
   * const properties = await handle.getProperties();
   * const windowHandle = properties.get('window');
   * const documentHandle = properties.get('document');
   * await handle.dispose();
   * ```
   */
  getProperties(): Promise<Map<string, JSHandle>>;

  /**
   * Fetches a single property from the referenced object.
   * @param propertyName property to get
   */
  getProperty(propertyName: string): Promise<JSHandle>;
}

/**
 * ElementHandle represents an in-page DOM element. ElementHandles can be created with the page.$ method.
 * ```js
 * const { chromium } = require('playwright');  // Or 'firefox' or 'webkit'.
 *
 * (async () => {
 *   const browser = await chromium.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   const hrefElement = await page.$('a');
 *   await hrefElement.click();
 *   // ...
 * })();
 * ```
 * ElementHandle prevents DOM element from garbage collection unless the handle is disposed. ElementHandles are auto-disposed when their origin frame gets navigated.
 * ElementHandle instances can be used as an argument in `page.$eval()` and `page.evaluate()` methods.
 */
export interface ElementHandle<T = Node> extends JSHandle<T> {
  /**
   * The method runs `element.querySelector` within the page. If no element matches the selector, the return value resolves to `null`.
   * @param selector A selector to query element for
   */
  $<K extends keyof HTMLElementTagNameMap>(
    selector: K
  ): Promise<ElementHandleForTag<K> | null>;
  $(selector: string): Promise<HTMLOrSVGElementHandle | null>;

  /**
   * The method runs `element.querySelectorAll` within the page. If no elements match the selector, the return value resolves to `[]`.
   * @param selector A selector to query element for
   */
  $$<K extends keyof HTMLElementTagNameMap>(
    selector: K
  ): Promise<ElementHandleForTag<K>[]>;
  $$(selector: string): Promise<HTMLOrSVGElementHandle[]>;

  /**
   * This method runs `document.querySelector` within the element and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const tweetHandle = await page.$('.tweet');
   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe('100');
   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe('10');
   * ```
   * @param selector A selector to query page for
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $eval<K extends keyof HTMLElementTagNameMap, R, Arg>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $eval<R, Arg>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement, Arg, R>,
    arg: Arg
  ): Promise<R>;
  $eval<K extends keyof HTMLElementTagNameMap, R>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K], void, R>,
    arg?: any
  ): Promise<R>;
  $eval<R>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement, void, R>,
    arg?: any
  ): Promise<R>;

  /**
   * This method runs `document.querySelectorAll` within the element and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```html
   * <div class="feed">
   *   <div class="tweet">Hello!</div>
   *   <div class="tweet">Hi!</div>
   * </div>
   * ```
   * ```js
   * const feedHandle = await page.$('.feed');
   * expect(await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))).toEqual(['Hello!', 'Hi!']);
   * ```
   * @param selector A selector to query page for
   * @param pageFunction Function to be evaluated in browser context
   * @param arg Optional argument to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $$eval<K extends keyof HTMLElementTagNameMap, R, Arg>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K][], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $$eval<R, Arg>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement[], Arg, R>,
    arg: Arg
  ): Promise<R>;
  $$eval<K extends keyof HTMLElementTagNameMap, R>(
    selector: K,
    pageFunction: PageFunctionOn<HTMLElementTagNameMap[K][], void, R>,
    arg?: any
  ): Promise<R>;
  $$eval<R>(
    selector: string,
    pageFunction: PageFunctionOn<HTMLOrSVGElement[], void, R>,
    arg?: any
  ): Promise<R>;
  /**
   * This method returns the bounding box of the element (relative to the main frame), or `null` if the element is not visible.
   */
  boundingBox(): Promise<null | ElementHandleBoundingBox>;

  /**
   * If element is not already checked, it scrolls it into view if needed, and then uses elementHandle.click to click in the center of the element.
   * @param options
   * @returns Promise which resolves when the element is successfully checked. Promise gets rejected if the operation fails.
   */
  check(options?: ElementHandleCheckOptions): Promise<void>;

  /**
   * This method scrolls element into view if needed, and then uses page.mouse to click in the center of the element.
   * If the element is detached from DOM, the method throws an error.
   * @param options
   * @returns Promise which resolves when the element is successfully clicked. Promise gets rejected if the element is detached from DOM.
   */
  click(options?: ElementHandleClickOptions): Promise<void>;

  /**
   * @returns Resolves to the content frame for element handles referencing iframe nodes, or `null` otherwise
   */
  contentFrame(): Promise<null | Frame>;

  /**
   * This method scrolls element into view if needed, and then uses page.mouse to click in the center of the element.
   * If the element is detached from DOM, the method throws an error.
   * Bear in mind that if the first click of the `dblclick()` triggers a navigation event, there will be an exception.
   *
   * **NOTE** `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.
   * @param options
   * @returns Promise which resolves when the element is successfully double clicked. Promise gets rejected if the element is detached from DOM.
   */
  dblclick(options?: ElementHandleDblclickOptions): Promise<void>;

  /**
   * This method focuses the element and triggers an `input` event after filling.
   * If element is not a text `<input>`, `<textarea>` or `[contenteditable]` element, the method throws an error.
   * @param value Value to set for the `<input>`, `<textarea>` or `[contenteditable]` element.
   * @param options
   * @returns Promise which resolves when the element is successfully filled.
   */
  fill(value: string, options?: ElementHandleFillOptions): Promise<void>;

  /**
   * Calls focus on the element.
   */
  focus(): Promise<void>;

  /**
   * This method scrolls element into view if needed, and then uses page.mouse to hover over the center of the element.
   * If the element is detached from DOM, the method throws an error.
   * @param options
   * @returns Promise which resolves when the element is successfully hovered.
   */
  hover(options?: ElementHandleHoverOptions): Promise<void>;

  /**
   * @returns Returns the frame containing the given element.
   */
  ownerFrame(): Promise<null | Frame>;

  /**
   * Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also be generated. The `text` option can be specified to force an input event to be generated.
   *
   * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift` will type the text in upper case.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   * @param options
   */
  press(key: string, options?: ElementHandlePressOptions): Promise<void>;

  /**
   * This method scrolls element into view if needed before taking a screenshot. If the element is detached from DOM, the method throws an error.
   * @param options Screenshot options.
   * @returns Promise which resolves to buffer with the captured screenshot.
   */
  screenshot(options?: ElementHandleScreenshotOptions): Promise<Buffer>;

  /**
   * This method tries to scroll element into view, unless it is completely visible as defined by IntersectionObserver's `ratio`.
   * Throws when `elementHandle` does not point to an element connected to a Document or a ShadowRoot.
   *
   * **NOTE** If javascript is disabled, element is scrolled into view even when already completely visible.
   * @returns Resolves after the element has been scrolled into view.
   */
  scrollIntoViewIfNeeded(): Promise<void>;

  /**
   * Triggers a `change` and `input` event once all the provided options have been selected.
   * If element is not a `<select>` element, the method throws an error.
   * ```js
   * // single selection matching the value
   * handle.selectOption('blue');
   *
   * // single selection matching both the value and the label
   * handle.selectOption({ value: 'blue', label: 'Blue' });
   *
   * // multiple selection
   * handle.selectOption('red', 'green', 'blue');
   *
   * // multiple selection for blue, red and second option
   * handle.selectOption({ value: 'blue' }, { index: 2 }, 'red');
   * ```
   * @param values Options to select. If the `<select>` has the `multiple` attribute, all matching options are selected, otherwise only the first option matching one of the passed options is selected. String values are equivalent to `{value:'string'}`. Option is considered matching if all specified properties match.
   * @param options
   * @returns An array of option values that have been successfully selected.
   */
  selectOption(
    values:
      | string
      | ElementHandle
      | Array<string>
      | ElementHandleSelectOptionValues
      | Array<ElementHandle>
      | Array<Object>,
    options?: ElementHandleSelectOptionOptions
  ): Promise<Array<string>>;

  /**
   * This method expects `elementHandle` to point to an input element.
   * Sets the value of the file input to these file paths or files. If some of the  `filePaths` are relative paths, then they are resolved relative to the current working directory. For empty array, clears the selected files.
   * @param files
   * @param options
   */
  setInputFiles(
    files:
      | string
      | Array<string>
      | ElementHandleSetInputFilesFiles
      | Array<Object>,
    options?: ElementHandleSetInputFilesOptions
  ): Promise<void>;

  toString(): string;

  /**
   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
   * To press a special key, like `Control` or `ArrowDown`, use `elementHandle.press`.
   * ```js
   * await elementHandle.type('Hello'); // Types instantly
   * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
   * ```
   * An example of typing into a text field and then submitting the form:
   * ```js
   * const elementHandle = await page.$('input');
   * await elementHandle.type('some text');
   * await elementHandle.press('Enter');
   * ```
   * @param text A text to type into a focused element.
   * @param options
   */
  type(text: string, options?: ElementHandleTypeOptions): Promise<void>;

  /**
   * If element is not already unchecked, it scrolls it into view if needed, and then uses elementHandle.click to click in the center of the element.
   * @param options
   * @returns Promise which resolves when the element is successfully unchecked. Promise gets rejected if the operation fails.
   */
  uncheck(options?: ElementHandleUncheckOptions): Promise<void>;
}

/**
 * BrowserType provides methods to launch a specific browser instance or connect to an existing one.
 * The following is a typical example of using Playwright to drive automation:
 * ```js
 * const { chromium } = require('playwright');  // Or 'firefox' or 'webkit'.
 *
 * (async () => {
 *   const browser = await chromium.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   // other actions...
 *   await browser.close();
 * })();
 * ```
 */
export interface BrowserType<Browser> {
  /**
   * This methods attaches Playwright to an existing browser instance.
   * @param options
   */
  connect(options: BrowserTypeConnectOptions): Promise<Browser>;

  /**
   * @returns A path where Playwright expects to find a bundled browser executable.
   */
  executablePath(): string;

  /**
   * You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:
   * ```js
   * const browser = await chromium.launch({  // Or 'firefox' or 'webkit'.
   *   ignoreDefaultArgs: ['--mute-audio']
   * });
   * ```
   *
   * **Chromium-only** Playwright can also be used to control the Chrome browser, but it works best with the version of Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath` option with extreme caution.
   * If Google Chrome (rather than Chromium) is preferred, a Chrome Canary or Dev Channel build is suggested.
   * In browserType.launch([options]) above, any mention of Chromium also applies to Chrome.
   * See `this article` for a description of the differences between Chromium and Chrome. `This article` describes some differences for Linux users.
   * @param options Set of configurable options to set on the browser. Can have the following fields:
   * @returns Promise which resolves to browser instance.
   */
  launch(options?: BrowserTypeLaunchOptions): Promise<Browser>;

  /**
   * Launches browser instance that uses persistent storage located at `userDataDir`.
   * @param userDataDir Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for Chromium and Firefox.
   * @param options Set of configurable options to set on the browser. Can have the following fields:
   * @returns Promise which resolves to the browser app instance.
   */
  launchPersistentContext(
    userDataDir: string,
    options?: BrowserTypeLaunchPersistentContextOptions
  ): Promise<BrowserContext>;

  /**
   * Launches browser server that client can connect to. An example of launching a browser executable and connecting to it later:
   * ```js
   * const { chromium } = require('playwright');  // Or 'webkit' or 'firefox'.
   *
   * (async () => {
   *   const browserServer = await chromium.launchServer();
   *   const wsEndpoint = browserServer.wsEndpoint();
   *   // Use web socket endpoint later to establish a connection.
   *   const browser = await chromium.connect({ wsEndpoint });
   *   // Close browser instance.
   *   await browserServer.close();
   * })();
   * ```
   * @param options Set of configurable options to set on the browser. Can have the following fields:
   * @returns Promise which resolves to the browser app instance.
   */
  launchServer(
    options?: BrowserTypeLaunchServerOptions
  ): Promise<BrowserServer>;

  /**
   * Returns browser name. For example: `'chromium'`, `'webkit'` or `'firefox'`.
   */
  name(): string;
}

// This is required to not export everything by default. See https://github.com/Microsoft/TypeScript/issues/19545#issuecomment-340490459
export {};

/**
 * A Browser is created when Playwright connects to a browser instance, either through `browserType.launch` or `browserType.connect`.
 * An example of using a Browser to create a Page:
 * ```js
 * const { firefox } = require('playwright');  // Or 'chromium' or 'webkit'.
 *
 * (async () => {
 *   const browser = await firefox.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await browser.close();
 * })();
 * ```
 * See ChromiumBrowser, FirefoxBrowser and WebKitBrowser for browser-specific features. Note that browserType.connect(options) and browserType.launch([options]) always return a specific browser instance, based on the browser being connected to or launched.
 */
export interface Browser extends EventEmitter {
  on(event: "disconnected", listener: () => void): this;

  once(event: "disconnected", listener: () => void): this;

  addListener(event: "disconnected", listener: () => void): this;

  /**
   * In case this browser is obtained using browserType.launch, closes the browser and all of its pages (if any were opened).
   * In case this browser is obtained using browserType.connect, clears all created contexts belonging to this browser and disconnects from the browser server.
   * The Browser object itself is considered to be disposed and cannot be used anymore.
   */
  close(): Promise<void>;

  /**
   * Returns an array of all open browser contexts. In a newly created browser, this will return zero
   * browser contexts.
   * ```js
   * const browser = await pw.webkit.launch();
   * console.log(browser.contexts().length); // prints `0`
   *
   * const context = await browser.newContext();
   * console.log(browser.contexts().length); // prints `1`
   * ```
   */
  contexts(): Array<BrowserContext>;

  /**
   * Indicates that the browser is connected.
   */
  isConnected(): boolean;

  /**
   * Creates a new browser context. It won't share cookies/cache with other browser contexts.
   * ```js
   * (async () => {
   *   const browser = await playwright.firefox.launch();  // Or 'chromium' or 'webkit'.
   *   // Create a new incognito browser context.
   *   const context = await browser.newContext();
   *   // Create a new page in a pristine context.
   *   const page = await context.newPage();
   *   await page.goto('https://example.com');
   * })();
   * ```
   * @param options
   */
  newContext(options?: BrowserNewContextOptions): Promise<BrowserContext>;

  /**
   * Creates a new page in a new browser context. Closing this page will close the context as well.
   * This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and testing frameworks should explicitly create browser.newContext followed by the browserContext.newPage to control their exact life times.
   * @param options
   */
  newPage(options?: BrowserNewPageOptions): Promise<Page>;
}

/**
 * BrowserContexts provide a way to operate multiple independent browser sessions.
 * If a page opens another page, e.g. with a `window.open` call, the popup will belong to the parent page's browser
 * context.
 * Playwright allows creation of "incognito" browser contexts with `browser.newContext()` method.
 * "Incognito" browser contexts don't write any browsing data to disk.
 * ```js
 * // Create a new incognito browser context
 * const context = await browser.newContext();
 * // Create a new page inside context.
 * const page = await context.newPage();
 * await page.goto('https://example.com');
 * // Dispose context once it's no longer needed.
 * await context.close();
 * ```
 */
export interface BrowserContext extends EventEmitter {
  on(event: "close", listener: () => void): this;

  /**
   * The event is emitted when a new Page is created in the BrowserContext. The page may still be loading. The event will also fire for popup pages. See also `Page.on('popup')` to receive events about popups relevant to a specific page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [page] = await Promise.all([
   *   context.waitForEvent('page'),
   *   page.click('a[target=_blank]'),
   * ]);
   * console.log(await page.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  on(event: "page", listener: (page: Page) => void): this;

  once(event: "close", listener: () => void): this;

  /**
   * The event is emitted when a new Page is created in the BrowserContext. The page may still be loading. The event will also fire for popup pages. See also `Page.on('popup')` to receive events about popups relevant to a specific page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [page] = await Promise.all([
   *   context.waitForEvent('page'),
   *   page.click('a[target=_blank]'),
   * ]);
   * console.log(await page.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  once(event: "page", listener: (page: Page) => void): this;

  addListener(event: "close", listener: () => void): this;

  /**
   * The event is emitted when a new Page is created in the BrowserContext. The page may still be loading. The event will also fire for popup pages. See also `Page.on('popup')` to receive events about popups relevant to a specific page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [page] = await Promise.all([
   *   context.waitForEvent('page'),
   *   page.click('a[target=_blank]'),
   * ]);
   * console.log(await page.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  addListener(event: "page", listener: (page: Page) => void): this;

  /**
   * ```js
   * await browserContext.addCookies([cookieObject1, cookieObject2]);
   * ```
   * @param cookies
   */
  addCookies(cookies: Array<BrowserContextAddCookiesCookies>): Promise<void>;

  /**
   * Adds a script which would be evaluated in one of the following scenarios:
   *
   * Whenever a page is created in the browser context or is navigated.
   * Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.
   *
   * The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
   * An example of overriding `Math.random` before the page loads:
   * ```js
   * // preload.js
   * Math.random = () => 42;
   * ```
   * ```js
   * // In your playwright script, assuming the preload.js file is in same folder.
   * await browserContext.addInitScript({
   *   path: 'preload.js'
   * });
   * ```
   *
   * **NOTE** The order of evaluation of multiple scripts installed via browserContext.addInitScript(script[, arg]) and page.addInitScript(script[, arg]) is not defined.
   * @param script Script to be evaluated in all pages in the browser context.
   * @param arg Optional argument to pass to `script` (only supported when passing a function).
   */
  addInitScript(
    script: Function | string | BrowserContextAddInitScriptScript,
    arg?: Serializable
  ): Promise<void>;

  /**
   * Clears context cookies.
   */
  clearCookies(): Promise<void>;

  /**
   * Clears all permission overrides for the browser context.
   * ```js
   * const context = await browser.newContext();
   * await context.grantPermissions(['clipboard-read']);
   * // do stuff ..
   * context.clearPermissions();
   * ```
   */
  clearPermissions(): Promise<void>;

  /**
   * Closes the browser context. All the pages that belong to the browser context
   * will be closed.
   *
   * **NOTE** the default browser context cannot be closed.
   */
  close(): Promise<void>;

  /**
   * If no URLs are specified, this method returns all cookies.
   * If URLs are specified, only cookies that affect those URLs are returned.
   * @param urls
   */
  cookies(urls?: string | Array<string>): Promise<Array<BrowserContextCookies>>;

  /**
   * The method adds a function called `name` on the `window` object of every frame in every page in the context.
   * When called, the function executes `playwrightFunction` in node.js and returns a Promise which resolves to the return value of `playwrightFunction`.
   * If the `playwrightFunction` returns a Promise, it will be awaited.
   * See page.exposeFunction(name, playwrightFunction) for page-only version.
   *
   * **NOTE** Functions installed via `page.exposeFunction` survive navigations.
   *
   * An example of adding an `md5` function to all pages in the context:
   * ```js
   * const { webkit } = require('playwright');  // Or 'chromium' or 'firefox'.
   * const crypto = require('crypto');
   *
   * (async () => {
   *   const browser = await webkit.launch({ headless: false });
   *   const context = await browser.newContext();
   *   await context.exposeFunction('md5', text => crypto.createHash('md5').update(text).digest('hex'));
   *   const page = await context.newPage();
   *   await page.setContent(`
   *     <script>
   *       async function onClick() {
   *         document.querySelector('div').textContent = await window.md5('PLAYWRIGHT');
   *       }
   *     </script>
   *     <button onclick="onClick()">Click me</button>
   *     <div></div>
   *   `);
   *   await page.click('button');
   * })();
   * ```
   * @param name Name of the function on the window object.
   * @param playwrightFunction Callback function that will be called in the Playwright's context.
   */
  exposeFunction(name: string, playwrightFunction: Function): Promise<void>;

  /**
   * Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if specified.
   * @param permissions A permission or an array of permissions to grant. Permissions can be one of the following values:  - `'*'`
   *  - `'geolocation'`
   *  - `'midi'`
   *  - `'midi-sysex'` (system-exclusive midi)
   *  - `'notifications'`
   *  - `'push'`
   *  - `'camera'`
   *  - `'microphone'`
   *  - `'background-sync'`
   *  - `'ambient-light-sensor'`
   *  - `'accelerometer'`
   *  - `'gyroscope'`
   *  - `'magnetometer'`
   *  - `'accessibility-events'`
   *  - `'clipboard-read'`
   *  - `'clipboard-write'`
   *  - `'payment-handler'`
   * @param options
   */
  grantPermissions(
    permissions: Array<string>,
    options?: BrowserContextGrantPermissionsOptions
  ): Promise<void>;

  /**
   * Creates a new page in the browser context.
   */
  newPage(): Promise<Page>;

  /**
   * @returns All open pages in the context. Non visible pages, such as `"background_page"`, will not be listed here. You can find them using chromiumBrowserContext.backgroundPages().
   */
  pages(): Array<Page>;

  /**
   * Routing provides the capability to modify network requests that are made by any page in the browser context.
   * Once route is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.
   * An example of a naïve handler that aborts all image requests:
   * ```js
   * const context = await browser.newContext();
   * await context.route('**\/*.{png,jpg,jpeg}', route => route.abort());
   * const page = await context.newPage();
   * await page.goto('https://example.com');
   * await browser.close();
   * ```
   * or the same snippet using a regex pattern instead:
   * ```js
   * const context = await browser.newContext();
   * await context.route(/(\.png$)|(\.jpg$)/, route => route.abort());
   * const page = await context.newPage();
   * await page.goto('https://example.com');
   * await browser.close();
   * ```
   * Page routes (set up with page.route(url, handler)) take precedence over browser context routes when request matches both handlers.
   *
   * **NOTE** Enabling routing disables http cache.
   * @param url A glob pattern, regex pattern or predicate receiving URL to match while routing.
   * @param handler handler function to route the request.
   */
  route(
    url: string | RegExp | ((arg0: string) => boolean),
    handler: (arg0: Route, arg1: Request) => void
  ): Promise<void>;

  /**
   * This setting will change the default maximum navigation time for the following methods and related shortcuts:
   *
   * page.goBack([options])
   * page.goForward([options])
   * page.goto(url[, options])
   * page.reload([options])
   * page.setContent(html[, options])
   * page.waitForNavigation([options])
   *
   *
   * **NOTE** `page.setDefaultNavigationTimeout` and `page.setDefaultTimeout` take priority over `browserContext.setDefaultNavigationTimeout`.
   * @param timeout Maximum navigation time in milliseconds
   */
  setDefaultNavigationTimeout(timeout: number): void;

  /**
   * This setting will change the default maximum time for all the methods accepting `timeout` option.
   *
   * **NOTE** `page.setDefaultNavigationTimeout`, `page.setDefaultTimeout` and `browserContext.setDefaultNavigationTimeout` take priority over `browserContext.setDefaultTimeout`.
   * @param timeout Maximum time in milliseconds
   */
  setDefaultTimeout(timeout: number): void;

  /**
   * The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged with page-specific extra HTTP headers set with page.setExtraHTTPHeaders(). If page overrides a particular header, page-specific header value will be used instead of the browser context header value.
   *
   * **NOTE** `browserContext.setExtraHTTPHeaders` does not guarantee the order of headers in the outgoing requests.
   * @param headers An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  setExtraHTTPHeaders(headers: Object): Promise<void>;

  /**
   * Sets the contexts's geolocation. Passing `null` or `undefined` emulates position unavailable.
   * ```js
   * await browserContext.setGeolocation({latitude: 59.95, longitude: 30.31667});
   * ```
   *
   * **NOTE** Consider using browserContext.grantPermissions to grant permissions for the browser context pages to read its geolocation.
   * @param geolocation
   */
  setGeolocation(
    geolocation: null | BrowserContextSetGeolocationGeolocation
  ): Promise<void>;

  /**
   * Provide credentials for HTTP authentication.
   * To disable authentication, pass `null`.
   * @param httpCredentials
   */
  setHTTPCredentials(
    httpCredentials: null | BrowserContextSetHTTPCredentialsHttpCredentials
  ): Promise<void>;

  /**
   * @param offline Whether to emulate network being offline for the browser context.
   */
  setOffline(offline: boolean): Promise<void>;

  waitForEvent(
    event: "close",
    optionsOrPredicate?: { predicate?: () => boolean; timeout?: number }
  ): Promise<void>;

  /**
   * The event is emitted when a new Page is created in the BrowserContext. The page may still be loading. The event will also fire for popup pages. See also `Page.on('popup')` to receive events about popups relevant to a specific page.
   * The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.
   * ```js
   * const [page] = await Promise.all([
   *   context.waitForEvent('page'),
   *   page.click('a[target=_blank]'),
   * ]);
   * console.log(await page.evaluate('location.href'));
   * ```
   *
   * **NOTE** Use `page.waitForLoadState([state[, options]])` to wait until the page gets to a particular state (you should not need it in most cases).
   */
  waitForEvent(
    event: "page",
    optionsOrPredicate?: {
      predicate?: (page: Page) => boolean;
      timeout?: number;
    }
  ): Promise<Page>;
}

/**
 * ConsoleMessage objects are dispatched by page via the 'console' event.
 */
export interface ConsoleMessage {
  args(): Array<JSHandle>;

  location(): ConsoleMessageLocation;

  text(): string;

  /**
   * One of the following values: `'log'`, `'debug'`, `'info'`, `'error'`, `'warning'`, `'dir'`, `'dirxml'`, `'table'`, `'trace'`, `'clear'`, `'startGroup'`, `'startGroupCollapsed'`, `'endGroup'`, `'assert'`, `'profile'`, `'profileEnd'`, `'count'`, `'timeEnd'`.
   */
  type(): string;
}

/**
 * Dialog objects are dispatched by page via the 'dialog' event.
 * An example of using `Dialog` class:
 * ```js
 * const { chromium } = require('playwright');  // Or 'firefox' or 'webkit'.
 *
 * (async () => {
 *   const browser = await chromium.launch();
 *   const page = await browser.newPage();
 *   page.on('dialog', async dialog => {
 *     console.log(dialog.message());
 *     await dialog.dismiss();
 *     await browser.close();
 *   });
 *   page.evaluate(() => alert('1'));
 * })();
 * ```
 */
export interface Dialog {
  /**
   * @param promptText A text to enter in prompt. Does not cause any effects if the dialog's `type` is not prompt.
   * @returns Promise which resolves when the dialog has been accepted.
   */
  accept(promptText?: string): Promise<void>;

  /**
   * @returns If dialog is prompt, returns default prompt value. Otherwise, returns empty string.
   */
  defaultValue(): string;

  /**
   * @returns Promise which resolves when the dialog has been dismissed.
   */
  dismiss(): Promise<void>;

  /**
   * @returns A message displayed in the dialog.
   */
  message(): string;

  /**
   * @returns Dialog's type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.
   */
  type(): string;
}

/**
 * Download objects are dispatched by page via the 'download' event.
 * All the downloaded files belonging to the browser context are deleted when the browser context is closed. All downloaded files are deleted when the browser closes.
 * Download event is emitted once the download starts. Download path becomes available
 * once download completes:
 * ```js
 * const [ download ] = await Promise.all([
 *   page.waitForEvent('download'), // wait for download to start
 *   page.click('a')
 * ]);
 * // wait for download to complete
 * const path = await download.path();
 * ...
 * ```
 *
 * **NOTE** Browser context **must** be created with the `acceptDownloads` set to `true` when user needs access to the downloaded content. If `acceptDownloads` is not set or set to `false`, download events are emitted, but the actual download is not performed and user has no access to the downloaded files.
 */
export interface Download {
  /**
   * Returns readable stream for current download or `null` if download failed.
   */
  createReadStream(): Promise<null | Readable>;

  /**
   * Deletes the downloaded file.
   */
  delete(): Promise<void>;

  /**
   * Returns download error if any.
   */
  failure(): Promise<null | string>;

  /**
   * Returns path to the downloaded file in case of successful download.
   */
  path(): Promise<null | string>;

  /**
   * Returns downloaded url.
   */
  url(): string;
}

/**
 * Keyboard provides an api for managing a virtual keyboard. The high level api is `keyboard.type`, which takes raw characters and generates proper keydown, keypress/input, and keyup events on your page.
 * For finer control, you can use `keyboard.down`, `keyboard.up`, and `keyboard.insertText` to manually fire events as if they were generated from a real keyboard.
 * An example of holding down `Shift` in order to select and delete some text:
 * ```js
 * await page.keyboard.type('Hello World!');
 * await page.keyboard.press('ArrowLeft');
 *
 * await page.keyboard.down('Shift');
 * for (let i = 0; i < ' World'.length; i++)
 *   await page.keyboard.press('ArrowLeft');
 * await page.keyboard.up('Shift');
 *
 * await page.keyboard.press('Backspace');
 * // Result text will end up saying 'Hello!'
 * ```
 * An example of pressing `A`
 * ```js
 * await page.keyboard.down('Shift');
 * await page.keyboard.press('KeyA');
 * await page.keyboard.up('Shift');
 * ```
 *
 * **NOTE** On MacOS, keyboard shortcuts like `⌘ A` -> Select All do not work. See #1313
 */
export interface Keyboard {
  /**
   * Dispatches a `keydown` event.
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also generated.
   * If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that modifier active. To release the modifier key, use `keyboard.up`.
   * After the key is pressed once, subsequent calls to `keyboard.down` will have repeat set to true. To release the key, use `keyboard.up`.
   *
   * **NOTE** Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   */
  down(key: string): Promise<void>;

  /**
   * Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.
   * ```js
   * page.keyboard.insertText('嗨');
   * ```
   *
   * **NOTE** Modifier keys DO NOT effect `keyboard.insertText`. Holding down `Shift` will not type the text in upper case.
   * @param text Sets input to the specified text value.
   */
  insertText(text: string): Promise<void>;

  /**
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also generated. The `text` option can be specified to force an input event to be generated.
   *
   * **NOTE** Modifier keys DO effect `keyboard.press`. Holding down `Shift` will type the text in upper case.
   *
   * Shortcut for `keyboard.down` and `keyboard.up`.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   * @param options
   */
  press(key: string, options?: KeyboardPressOptions): Promise<void>;

  /**
   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
   * To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
   * ```js
   * await page.keyboard.type('Hello'); // Types instantly
   * await page.keyboard.type('World', {delay: 100}); // Types slower, like a user
   * ```
   *
   * **NOTE** Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.
   * @param text A text to type into a focused element.
   * @param options
   */
  type(text: string, options?: KeyboardTypeOptions): Promise<void>;

  /**
   * Dispatches a `keyup` event.
   * @param key Name of key to release, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   */
  up(key: string): Promise<void>;
}

/**
 * The Mouse class operates in main-frame CSS pixels relative to the top-left corner of the viewport.
 * Every `page` object has its own Mouse, accessible with `page.mouse`.
 * ```js
 * // Using ‘page.mouse’ to trace a 100x100 square.
 * await page.mouse.move(0, 0);
 * await page.mouse.down();
 * await page.mouse.move(0, 100);
 * await page.mouse.move(100, 100);
 * await page.mouse.move(100, 0);
 * await page.mouse.move(0, 0);
 * await page.mouse.up();
 * ```
 */
export interface Mouse {
  /**
   * Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.
   * @param x
   * @param y
   * @param options
   */
  click(x: number, y: number, options?: MouseClickOptions): Promise<void>;

  /**
   * Shortcut for `mouse.move`, `mouse.down`, `mouse.up`, `mouse.down` and `mouse.up`.
   * @param x
   * @param y
   * @param options
   */
  dblclick(x: number, y: number, options?: MouseDblclickOptions): Promise<void>;

  /**
   * Dispatches a `mousedown` event.
   * @param options
   */
  down(options?: MouseDownOptions): Promise<void>;

  /**
   * Dispatches a `mousemove` event.
   * @param x
   * @param y
   * @param options
   */
  move(x: number, y: number, options?: MouseMoveOptions): Promise<void>;

  /**
   * Dispatches a `mouseup` event.
   * @param options
   */
  up(options?: MouseUpOptions): Promise<void>;
}

/**
 * Whenever the page sends a request, such as for a network resource, the following events are emitted by playwright's page:
 *
 * `'request'` emitted when the request is issued by the page.
 * `'response'` emitted when/if the response is received for the request.
 * `'requestfinished'` emitted when the response body is downloaded and the request is complete.
 *
 * If request fails at some point, then instead of `'requestfinished'` event (and possibly instead of 'response' event), the  `'requestfailed'` event is emitted.
 *
 * **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request will complete with `'requestfinished'` event.
 *
 * If request gets a 'redirect' response, the request is successfully finished with the 'requestfinished' event, and a new request is  issued to a redirected url.
 */
export interface Request {
  /**
   * The method returns `null` unless this request has failed, as reported by
   * `requestfailed` event.
   * Example of logging of all the failed requests:
   * ```js
   * page.on('requestfailed', request => {
   *   console.log(request.url() + ' ' + request.failure().errorText);
   * });
   * ```
   * @returns Object describing request failure, if any
   */
  failure(): null | RequestFailure;

  /**
   * @returns A Frame that initiated this request.
   */
  frame(): Frame;

  /**
   * @returns An object with HTTP headers associated with the request. All header names are lower-case.
   */
  headers(): Object;

  /**
   * Whether this request is driving frame's navigation.
   */
  isNavigationRequest(): boolean;

  /**
   * @returns Request's method (GET, POST, etc.)
   */
  method(): string;

  /**
   * @returns Request's post body, if any.
   */
  postData(): null | string;

  /**
   * When the server responds with a redirect, Playwright creates a new Request object. The two requests are connected by `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to construct the whole redirect chain by repeatedly calling `redirectedFrom()`.
   * For example, if the website `http://example.com` redirects to `https://example.com`:
   * ```js
   * const response = await page.goto('http://example.com');
   * console.log(response.request().redirectedFrom().url()); // 'http://example.com'
   * ```
   * If the website `https://google.com` has no redirects:
   * ```js
   * const response = await page.goto('https://google.com');
   * console.log(response.request().redirectedFrom()); // null
   * ```
   * @returns Request that was redirected by the server to this one, if any.
   */
  redirectedFrom(): null | Request;

  /**
   * This method is the opposite of request.redirectedFrom():
   * ```js
   * console.log(request.redirectedFrom().redirectedTo() === request); // true
   * ```
   * @returns New request issued by the browser if the server responded with redirect.
   */
  redirectedTo(): null | Request;

  /**
   * Contains the request's resource type as it was perceived by the rendering engine.
   * ResourceType will be one of the following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`, `manifest`, `other`.
   */
  resourceType(): string;

  /**
   * @returns A matching Response object, or `null` if the response was not received due to error.
   */
  response(): Promise<null | Response>;

  /**
   * @returns URL of the request.
   */
  url(): string;
}

/**
 * Response class represents responses which are received by page.
 */
export interface Response {
  /**
   * @returns Promise which resolves to a buffer with response body.
   */
  body(): Promise<Buffer>;

  /**
   * @returns Waits for this response to finish, returns failure error if request failed.
   */
  finished(): Promise<null | Error>;

  /**
   * @returns A Frame that initiated this response.
   */
  frame(): Frame;

  /**
   * @returns An object with HTTP headers associated with the response. All header names are lower-case.
   */
  headers(): Object;

  /**
   * This method will throw if the response body is not parsable via `JSON.parse`.
   * @returns Promise which resolves to a JSON representation of response body.
   */
  json(): Promise<Object>;

  /**
   * Contains a boolean stating whether the response was successful (status in the range 200-299) or not.
   */
  ok(): boolean;

  /**
   * @returns A matching Request object.
   */
  request(): Request;

  /**
   * Contains the status code of the response (e.g., 200 for a success).
   */
  status(): number;

  /**
   * Contains the status text of the response (e.g. usually an "OK" for a success).
   */
  statusText(): string;

  /**
   * @returns Promise which resolves to a text representation of response body.
   */
  text(): Promise<string>;

  /**
   * Contains the URL of the response.
   */
  url(): string;
}

/**
 * Selectors can be used to install custom selector engines. See Working with selectors for more information.
 */
export interface Selectors {
  /**
   * An example of registering selector engine that queries elements based on a tag name:
   * ```js
   * const { selectors, firefox } = require('playwright');  // Or 'chromium' or 'webkit'.
   *
   * (async () => {
   *   // Must be a function that evaluates to a selector engine instance.
   *   const createTagNameEngine = () => ({
   *     // Creates a selector that matches given target when queried at the root.
   *     // Can return undefined if unable to create one.
   *     create(root, target) {
   *       return root.querySelector(target.tagName) === target ? target.tagName : undefined;
   *     },
   *
   *     // Returns the first element matching given selector in the root's subtree.
   *     query(root, selector) {
   *       return root.querySelector(selector);
   *     },
   *
   *     // Returns all elements matching given selector in the root's subtree.
   *     queryAll(root, selector) {
   *       return Array.from(root.querySelectorAll(selector));
   *     }
   *   });
   *
   *   // Register the engine. Selectors will be prefixed with "tag=".
   *   await selectors.register('tag', createTagNameEngine);
   *
   *   const browser = await firefox.launch();
   *   const page = await browser.newPage();
   *   await page.goto('https://example.com');
   *
   *   // Use the selector prefixed with its name.
   *   const button = await page.$('tag=button');
   *   // Combine it with other selector engines.
   *   await page.click('tag=div >> text="Click me"');
   *   // Can use it in any methods supporting selectors.
   *   const buttonCount = await page.$$eval('tag=button', buttons => buttons.length);
   *
   *   await browser.close();
   * })();
   * ```
   * @param name Name that is used in selectors as a prefix, e.g. `{name: 'foo'}` enables `foo=myselectorbody` selectors. May only contain `[a-zA-Z0-9_]` characters.
   * @param script Script that evaluates to a selector engine instance.
   * @param options
   */
  register(
    name: string,
    script: Function | string | SelectorsRegisterScript,
    options?: SelectorsRegisterOptions
  ): Promise<void>;
}

/**
 * Whenever a network route is set up with page.route(url, handler) or browserContext.route(url, handler), the `Route` object allows to handle the route.
 */
export interface Route {
  /**
   * Aborts the route's request.
   * @param errorCode Optional error code. Defaults to `failed`, could be one of the following:
   *  - `aborted` - An operation was aborted (due to user action)
   *  - `accessdenied` - Permission to access a resource, other than the network, was denied
   *  - `addressunreachable` - The IP address is unreachable. This usually means
   *  - that there is no route to the specified host or network.
   *  - `blockedbyclient` - The client chose to block the request.
   *  - `blockedbyresponse` - The request failed because the response was delivered along with requirements which are not met ('X-Frame-Options' and 'Content-Security-Policy' ancestor checks, for instance).
   *  - `connectionaborted` - A connection timed out as a result of not receiving an ACK for data sent.
   *  - `connectionclosed` - A connection was closed (corresponding to a TCP FIN).
   *  - `connectionfailed` - A connection attempt failed.
   *  - `connectionrefused` - A connection attempt was refused.
   *  - `connectionreset` - A connection was reset (corresponding to a TCP RST).
   *  - `internetdisconnected` - The Internet connection has been lost.
   *  - `namenotresolved` - The host name could not be resolved.
   *  - `timedout` - An operation timed out.
   *  - `failed` - A generic failure occurred.
   */
  abort(errorCode?: string): Promise<void>;

  /**
   * Continues route's request with optional overrides.
   * ```js
   * await page.route('**\/*', (route, request) => {
   *   // Override headers
   *   const headers = Object.assign({}, request.headers(), {
   *     foo: 'bar', // set "foo" header
   *     origin: undefined, // remove "origin" header
   *   });
   *   route.continue({headers});
   * });
   * ```
   * @param overrides Optional request overrides, which can be one of the following:
   */
  continue(overrides?: RouteContinueOverrides): Promise<void>;

  /**
   * Fulfills route's request with given response.
   * An example of fulfilling all requests with 404 responses:
   * ```js
   * await page.route('**\/*', route => {
   *   route.fulfill({
   *     status: 404,
   *     contentType: 'text/plain',
   *     body: 'Not Found!'
   *   });
   * });
   * ```
   * An example of serving static file:
   * ```js
   * await page.route('**\/xhr_endpoint', route => route.fulfill({ path: 'mock_data.json' }));
   * ```
   * @param response Response that will fulfill this route's request.
   */
  fulfill(response: RouteFulfillResponse): Promise<void>;

  /**
   * @returns A request to be routed.
   */
  request(): Request;
}

/**
 * The Accessibility class provides methods for inspecting Chromium's accessibility tree. The accessibility tree is used by assistive technology such as screen readers or switches.
 * Accessibility is a very platform-specific thing. On different platforms, there are different screen readers that might have wildly different output.
 * Blink - Chromium's rendering engine - has a concept of "accessibility tree", which is then translated into different platform-specific APIs. Accessibility namespace gives users
 * access to the Blink Accessibility Tree.
 * Most of the accessibility tree gets filtered out when converting from Blink AX Tree to Platform-specific AX-Tree or by assistive technologies themselves. By default, Playwright tries to approximate this filtering, exposing only the "interesting" nodes of the tree.
 */
export interface Accessibility {
  /**
   * Captures the current state of the accessibility tree. The returned object represents the root accessible node of the page.
   *
   * **NOTE** The Chromium accessibility tree contains nodes that go unused on most platforms and by
   * most screen readers. Playwright will discard them as well for an easier to process tree,
   * unless `interestingOnly` is set to `false`.
   *
   * An example of dumping the entire accessibility tree:
   * ```js
   * const snapshot = await page.accessibility.snapshot();
   * console.log(snapshot);
   * ```
   * An example of logging the focused node's name:
   * ```js
   * const snapshot = await page.accessibility.snapshot();
   * const node = findFocusedNode(snapshot);
   * console.log(node && node.name);
   *
   * function findFocusedNode(node) {
   *   if (node.focused)
   *     return node;
   *   for (const child of node.children || []) {
   *     const foundNode = findFocusedNode(child);
   *     return foundNode;
   *   }
   *   return null;
   * }
   * ```
   * @param options
   * @returns An AXNode object with the following properties:
   */
  snapshot(
    options?: AccessibilitySnapshotOptions
  ): Promise<null | AccessibilitySnapshot>;
}

export interface BrowserServer {
  /**
   * Emitted when the browser server closes.
   */
  on(event: "close", listener: () => void): this;

  /**
   * Emitted when the browser server closes.
   */
  once(event: "close", listener: () => void): this;

  /**
   * Emitted when the browser server closes.
   */
  addListener(event: "close", listener: () => void): this;

  /**
   * Closes the browser gracefully and makes sure the process is terminated.
   */
  close(): Promise<void>;

  /**
   * Kills the browser process.
   */
  kill(): void;

  /**
   * @returns Spawned browser application process.
   */
  process(): ChildProcess;

  /**
   * Browser websocket endpoint which can be used as an argument to browserType.connect(options) to establish connection to the browser.
   * @returns Browser websocket url.
   */
  wsEndpoint(): string;
}

/**
 * Coverage gathers information about parts of JavaScript and CSS that were used by the page.
 * An example of using JavaScript coverage to produce Istambul report for page load:
 * ```js
 * const { chromium } = require('.');
 * const v8toIstanbul = require('v8-to-istanbul');
 *
 * (async() => {
 *   const browser = await chromium.launch();
 *   const page = await browser.newPage();
 *   await page.coverage.startJSCoverage();
 *   await page.goto('https://chromium.org');
 *   const coverage = await page.coverage.stopJSCoverage();
 *   for (const entry of coverage) {
 *     const converter = new v8toIstanbul('', 0, { source: entry.source });
 *     await converter.load();
 *     converter.applyCoverage(entry.functions);
 *     console.log(JSON.stringify(converter.toIstanbul()));
 *   }
 *   await browser.close();
 * })();
 * ```
 */
export interface ChromiumCoverage {
  /**
   * @param options Set of configurable options for coverage
   * @returns Promise that resolves when coverage is started
   */
  startCSSCoverage(
    options?: ChromiumCoverageStartCSSCoverageOptions
  ): Promise<void>;

  /**
   * **NOTE** Anonymous scripts are ones that don't have an associated url. These are scripts that are dynamically created on the page using `eval` or `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous scripts will have `__playwright_evaluation_script__` as their URL.
   * @param options Set of configurable options for coverage
   * @returns Promise that resolves when coverage is started
   */
  startJSCoverage(
    options?: ChromiumCoverageStartJSCoverageOptions
  ): Promise<void>;

  /**
   * **NOTE** CSS Coverage doesn't include dynamically injected style tags without sourceURLs.
   * @returns Promise that resolves to the array of coverage reports for all stylesheets
   */
  stopCSSCoverage(): Promise<Array<ChromiumCoverageStopCSSCoverage>>;

  /**
   * **NOTE** JavaScript Coverage doesn't include anonymous scripts by default. However, scripts with sourceURLs are
   * reported.
   * @returns Promise that resolves to the array of coverage reports for all scripts
   */
  stopJSCoverage(): Promise<Array<ChromiumCoverageStopJSCoverage>>;
}

/**
 * Firefox browser instance does not expose Firefox-specific features.
 */
export interface FirefoxBrowser extends Browser {}

/**
 * WebKit browser instance does not expose WebKit-specific features.
 */
export interface WebKitBrowser extends Browser {}

interface WebKitBrowserNewPageOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | WebKitBrowserNewPageOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to `true`.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: WebKitBrowserNewPageOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: WebKitBrowserNewPageOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface WebKitBrowserNewPageOptionsHttpCredentials {
  username: string;

  password: string;
}

interface WebKitBrowserNewPageOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface WebKitBrowserNewPageOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface WebKitBrowserNewContextOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | WebKitBrowserNewContextOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to true.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: WebKitBrowserNewContextOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: WebKitBrowserNewContextOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface WebKitBrowserNewContextOptionsHttpCredentials {
  username: string;

  password: string;
}

interface WebKitBrowserNewContextOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface WebKitBrowserNewContextOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface FirefoxBrowserNewPageOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | FirefoxBrowserNewPageOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to `true`.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: FirefoxBrowserNewPageOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: FirefoxBrowserNewPageOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface FirefoxBrowserNewPageOptionsHttpCredentials {
  username: string;

  password: string;
}

interface FirefoxBrowserNewPageOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface FirefoxBrowserNewPageOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface FirefoxBrowserNewContextOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | FirefoxBrowserNewContextOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to true.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: FirefoxBrowserNewContextOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: FirefoxBrowserNewContextOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface FirefoxBrowserNewContextOptionsHttpCredentials {
  username: string;

  password: string;
}

interface FirefoxBrowserNewContextOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface FirefoxBrowserNewContextOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface ChromiumCoverageStopJSCoverage {
  /**
   * Script URL
   */
  url: string;

  /**
   * Script content, if applicable.
   */
  source?: string;

  /**
   * V8-specific coverage format.
   */
  functions: Array<ChromiumCoverageStopJSCoverageFunctions>;
}

interface ChromiumCoverageStopJSCoverageFunctions {
  functionName: string;

  ranges: Array<ChromiumCoverageStopJSCoverageFunctionsRanges>;
}

interface ChromiumCoverageStopJSCoverageFunctionsRanges {
  count: number;

  startOffset: number;

  endOffset: number;
}

interface ChromiumCoverageStopCSSCoverage {
  /**
   * StyleSheet URL
   */
  url: string;

  /**
   * StyleSheet content, if available.
   */
  text?: string;

  /**
   * StyleSheet ranges that were used. Ranges are sorted and non-overlapping.
   */
  ranges: Array<ChromiumCoverageStopCSSCoverageRanges>;
}

interface ChromiumCoverageStopCSSCoverageRanges {
  /**
   * A start offset in text, inclusive
   */
  start: number;

  /**
   * An end offset in text, exclusive
   */
  end: number;
}

interface ChromiumCoverageStartJSCoverageOptions {
  /**
   * Whether to reset coverage on every navigation. Defaults to `true`.
   */
  resetOnNavigation?: boolean;

  /**
   * Whether anonymous scripts generated by the page should be reported. Defaults to `false`.
   */
  reportAnonymousScripts?: boolean;
}

interface ChromiumCoverageStartCSSCoverageOptions {
  /**
   * Whether to reset coverage on every navigation. Defaults to `true`.
   */
  resetOnNavigation?: boolean;
}

interface ChromiumBrowserContextSetHTTPCredentialsHttpCredentials {
  /**
   * **required**
   */
  username: string;

  /**
   * **required**
   */
  password: string;
}

interface ChromiumBrowserContextSetGeolocationGeolocation {
  /**
   * Latitude between -90 and 90. **required**
   */
  latitude: number;

  /**
   * Longitude between -180 and 180. **required**
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface ChromiumBrowserContextGrantPermissionsOptions {
  /**
   * The origin to grant permissions to, e.g. "https://example.com".
   */
  origin?: string;
}

interface ChromiumBrowserContextCookies {
  name: string;

  value: string;

  domain: string;

  path: string;

  /**
   * Unix time in seconds.
   */
  expires: number;

  httpOnly: boolean;

  secure: boolean;

  sameSite: "Strict" | "Lax" | "None";
}

interface ChromiumBrowserContextAddInitScriptScript {
  /**
   * Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw script content.
   */
  content?: string;
}

interface ChromiumBrowserContextAddCookiesCookies {
  /**
   * **required**
   */
  name: string;

  /**
   * **required**
   */
  value: string;

  /**
   * either url or domain / path are required
   */
  url?: string;

  /**
   * either url or domain / path are required
   */
  domain?: string;

  /**
   * either url or domain / path are required
   */
  path?: string;

  /**
   * Unix time in seconds.
   */
  expires?: number;

  httpOnly?: boolean;

  secure?: boolean;

  sameSite?: "Strict" | "Lax" | "None";
}

interface AccessibilitySnapshot {
  /**
   * The role.
   */
  role: string;

  /**
   * A human readable name for the node.
   */
  name: string;

  /**
   * The current value of the node, if applicable.
   */
  value?: string | number;

  /**
   * An additional human readable description of the node, if applicable.
   */
  description?: string;

  /**
   * Keyboard shortcuts associated with this node, if applicable.
   */
  keyshortcuts?: string;

  /**
   * A human readable alternative to the role, if applicable.
   */
  roledescription?: string;

  /**
   * A description of the current value, if applicable.
   */
  valuetext?: string;

  /**
   * Whether the node is disabled, if applicable.
   */
  disabled?: boolean;

  /**
   * Whether the node is expanded or collapsed, if applicable.
   */
  expanded?: boolean;

  /**
   * Whether the node is focused, if applicable.
   */
  focused?: boolean;

  /**
   * Whether the node is modal, if applicable.
   */
  modal?: boolean;

  /**
   * Whether the node text input supports multiline, if applicable.
   */
  multiline?: boolean;

  /**
   * Whether more than one child can be selected, if applicable.
   */
  multiselectable?: boolean;

  /**
   * Whether the node is read only, if applicable.
   */
  readonly?: boolean;

  /**
   * Whether the node is required, if applicable.
   */
  required?: boolean;

  /**
   * Whether the node is selected in its parent node, if applicable.
   */
  selected?: boolean;

  /**
   * Whether the checkbox is checked, or "mixed", if applicable.
   */
  checked?: boolean | "mixed";

  /**
   * Whether the toggle button is checked, or "mixed", if applicable.
   */
  pressed?: boolean | "mixed";

  /**
   * The level of a heading, if applicable.
   */
  level?: number;

  /**
   * The minimum value in a node, if applicable.
   */
  valuemin?: number;

  /**
   * The maximum value in a node, if applicable.
   */
  valuemax?: number;

  /**
   * What kind of autocomplete is supported by a control, if applicable.
   */
  autocomplete?: string;

  /**
   * What kind of popup is currently being shown for a node, if applicable.
   */
  haspopup?: string;

  /**
   * Whether and in what way this node's value is invalid, if applicable.
   */
  invalid?: string;

  /**
   * Whether the node is oriented horizontally or vertically, if applicable.
   */
  orientation?: string;

  /**
   * Child AXNodes of this node, if any, if applicable.
   */
  children?: Array<Object>;
}

interface AccessibilitySnapshotOptions {
  /**
   * Prune uninteresting nodes from the tree. Defaults to `true`.
   */
  interestingOnly?: boolean;

  /**
   * The root DOM element for the snapshot. Defaults to the whole page.
   */
  root?: ElementHandle;
}

interface RouteFulfillResponse {
  /**
   * Response status code, defaults to `200`.
   */
  status?: number;

  /**
   * Optional response headers. Header values will be converted to a string.
   */
  headers?: Object;

  /**
   * If set, equals to setting `Content-Type` response header.
   */
  contentType?: string;

  /**
   * Optional response body.
   */
  body?: string | Buffer;

  /**
   * Optional file path to respond with. The content type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;
}

interface RouteContinueOverrides {
  /**
   * If set changes the request method (e.g. GET or POST)
   */
  method?: string;

  /**
   * If set changes the post data of request
   */
  postData?: string;

  /**
   * If set changes the request HTTP headers. Header values will be converted to a string.
   */
  headers?: Object;
}

interface SelectorsRegisterOptions {
  /**
   * Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but not any JavaScript objects from the frame's scripts. Defaults to `false`. Note that running as a content script is not guaranteed when this engine is used together with other registered engines.
   */
  contentScript?: boolean;
}

interface SelectorsRegisterScript {
  /**
   * Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw script content.
   */
  content?: string;
}

interface RequestFailure {
  /**
   * Human-readable error message, e.g. `'net::ERR_FAILED'`.
   */
  errorText: string;
}

export interface MouseUpOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;
}

interface MouseMoveOptions {
  /**
   * defaults to 1. Sends intermediate `mousemove` events.
   */
  steps?: number;
}

export interface MouseDownOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;
}

export interface MouseDblclickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

export interface MouseClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface KeyboardTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface KeyboardPressOptions {
  /**
   * Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface ConsoleMessageLocation {
  /**
   * URL of the resource if available.
   */
  url?: string;

  /**
   * 0-based line number in the resource if available.
   */
  lineNumber?: number;

  /**
   * 0-based column number in the resource if available.
   */
  columnNumber?: number;
}

interface BrowserContextSetHTTPCredentialsHttpCredentials {
  /**
   * **required**
   */
  username: string;

  /**
   * **required**
   */
  password: string;
}

interface BrowserContextSetGeolocationGeolocation {
  /**
   * Latitude between -90 and 90. **required**
   */
  latitude: number;

  /**
   * Longitude between -180 and 180. **required**
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface BrowserContextGrantPermissionsOptions {
  /**
   * The origin to grant permissions to, e.g. "https://example.com".
   */
  origin?: string;
}

interface BrowserContextCookies {
  name: string;

  value: string;

  domain: string;

  path: string;

  /**
   * Unix time in seconds.
   */
  expires: number;

  httpOnly: boolean;

  secure: boolean;

  sameSite: "Strict" | "Lax" | "None";
}

interface BrowserContextAddInitScriptScript {
  /**
   * Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw script content.
   */
  content?: string;
}

interface BrowserContextAddCookiesCookies {
  /**
   * **required**
   */
  name: string;

  /**
   * **required**
   */
  value: string;

  /**
   * either url or domain / path are required
   */
  url?: string;

  /**
   * either url or domain / path are required
   */
  domain?: string;

  /**
   * either url or domain / path are required
   */
  path?: string;

  /**
   * Unix time in seconds.
   */
  expires?: number;

  httpOnly?: boolean;

  secure?: boolean;

  sameSite?: "Strict" | "Lax" | "None";
}

interface BrowserNewPageOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | BrowserNewPageOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to `true`.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: BrowserNewPageOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: BrowserNewPageOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface BrowserNewPageOptionsHttpCredentials {
  username: string;

  password: string;
}

interface BrowserNewPageOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface BrowserNewPageOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface BrowserNewContextOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | BrowserNewContextOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to true.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: BrowserNewContextOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: BrowserNewContextOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface BrowserNewContextOptionsHttpCredentials {
  username: string;

  password: string;
}

interface BrowserNewContextOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface BrowserNewContextOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface ChromiumBrowserNewPageOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | ChromiumBrowserNewPageOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to `true`.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: ChromiumBrowserNewPageOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: ChromiumBrowserNewPageOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface ChromiumBrowserNewPageOptionsHttpCredentials {
  username: string;

  password: string;
}

interface ChromiumBrowserNewPageOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface ChromiumBrowserNewPageOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface ChromiumBrowserNewContextOptions {
  /**
   * Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
   */
  acceptDownloads?: boolean;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   */
  bypassCSP?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `null` disables the default viewport.
   */
  viewport?: null | ChromiumBrowserNewContextOptionsViewport;

  /**
   * Specific user agent to use in this context.
   */
  userAgent?: string;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported in Firefox.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to false.
   */
  hasTouch?: boolean;

  /**
   * Whether or not to enable or disable JavaScript in the context. Defaults to true.
   */
  javaScriptEnabled?: boolean;

  /**
   * Changes the timezone of the context. See ICU’s `metaZones.txt` for a list of supported timezone IDs.
   */
  timezoneId?: string;

  geolocation?: ChromiumBrowserNewContextOptionsGeolocation;

  /**
   * Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language` request header value as well as number and date formatting rules.
   */
  locale?: string;

  /**
   * A list of permissions to grant to all pages in this context. See browserContext.grantPermissions for more details.
   */
  permissions?: Array<string>;

  /**
   * An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  extraHTTPHeaders?: Object;

  /**
   * Whether to emulate network being offline. Defaults to `false`.
   */
  offline?: boolean;

  /**
   * Credentials for HTTP authentication.
   */
  httpCredentials?: ChromiumBrowserNewContextOptionsHttpCredentials;

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`. See page.emulateMedia(options) for more details. Defaults to '`light`'.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

interface ChromiumBrowserNewContextOptionsHttpCredentials {
  username: string;

  password: string;
}

interface ChromiumBrowserNewContextOptionsGeolocation {
  /**
   * Latitude between -90 and 90.
   */
  latitude: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude: number;

  /**
   * Non-negative accuracy value. Defaults to `0`.
   */
  accuracy?: number;
}

interface ChromiumBrowserNewContextOptionsViewport {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface ChromiumBrowserStartTracingOptions {
  /**
   * A path to write the trace file to.
   */
  path?: string;

  /**
   * captures screenshots in the trace.
   */
  screenshots?: boolean;

  /**
   * specify custom categories to use instead of default.
   */
  categories?: Array<string>;
}

interface BrowserTypeLaunchServerOptions {
  /**
   * Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
   */
  headless?: boolean;

  /**
   * Port to use for the web socket. Defaults to 0 that picks any available port.
   */
  port?: number;

  /**
   * Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. **BEWARE**: Playwright is only guaranteed to work with the bundled Chromium, Firefox or WebKit, use at your own risk.
   */
  executablePath?: string;

  /**
   * Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
   */
  args?: Array<string>;

  /**
   * If `true`, then do not use any of the default arguments. If an array is given, then filter out the given default arguments. Dangerous option; use with care. Defaults to `false`.
   */
  ignoreDefaultArgs?: boolean | Array<string>;

  /**
   * Close the browser process on Ctrl-C. Defaults to `true`.
   */
  handleSIGINT?: boolean;

  /**
   * Close the browser process on SIGTERM. Defaults to `true`.
   */
  handleSIGTERM?: boolean;

  /**
   * Close the browser process on SIGHUP. Defaults to `true`.
   */
  handleSIGHUP?: boolean;

  /**
   * Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;

  /**
   * Whether to pipe the browser process stdout and stderr into `process.stdout` and `process.stderr`. Defaults to `false`.
   */
  dumpio?: boolean;

  /**
   * Specify environment variables that will be visible to the browser. Defaults to `process.env`.
   */
  env?: Object;

  /**
   * **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
   */
  devtools?: boolean;
}

interface BrowserTypeLaunchPersistentContextOptions {
  /**
   * Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
   */
  headless?: boolean;

  /**
   * Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. **BEWARE**: Playwright is only guaranteed to work with the bundled Chromium, Firefox or WebKit, use at your own risk.
   */
  executablePath?: string;

  /**
   * Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
   */
  args?: Array<string>;

  /**
   * If `true`, then do not use any of the default arguments. If an array is given, then filter out the given default arguments. Dangerous option; use with care. Defaults to `false`.
   */
  ignoreDefaultArgs?: boolean | Array<string>;

  /**
   * Close the browser process on Ctrl-C. Defaults to `true`.
   */
  handleSIGINT?: boolean;

  /**
   * Close the browser process on SIGTERM. Defaults to `true`.
   */
  handleSIGTERM?: boolean;

  /**
   * Close the browser process on SIGHUP. Defaults to `true`.
   */
  handleSIGHUP?: boolean;

  /**
   * Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;

  /**
   * Whether to pipe the browser process stdout and stderr into `process.stdout` and `process.stderr`. Defaults to `false`.
   */
  dumpio?: boolean;

  /**
   * Specify environment variables that will be visible to the browser. Defaults to `process.env`.
   */
  env?: Object;

  /**
   * **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
   */
  devtools?: boolean;

  /**
   * Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.
   */
  slowMo?: number;
}

interface BrowserTypeLaunchOptions {
  /**
   * Whether to run browser in headless mode. More details for Chromium and Firefox. Defaults to `true` unless the `devtools` option is `true`.
   */
  headless?: boolean;

  /**
   * Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is resolved relative to current working directory. Note that Playwright only works with the bundled Chromium, Firefox or WebKit, use at your own risk.
   */
  executablePath?: string;

  /**
   * Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
   */
  args?: Array<string>;

  /**
   * If `true`, Playwright does not pass its own configurations args and only uses the ones from `args`. If an array is given, then filters out the given default arguments. Dangerous option; use with care. Defaults to `false`.
   */
  ignoreDefaultArgs?: boolean | Array<string>;

  /**
   * Close the browser process on Ctrl-C. Defaults to `true`.
   */
  handleSIGINT?: boolean;

  /**
   * Close the browser process on SIGTERM. Defaults to `true`.
   */
  handleSIGTERM?: boolean;

  /**
   * Close the browser process on SIGHUP. Defaults to `true`.
   */
  handleSIGHUP?: boolean;

  /**
   * Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;

  /**
   * Whether to pipe the browser process stdout and stderr into `process.stdout` and `process.stderr`. Defaults to `false`.
   */
  dumpio?: boolean;

  /**
   * Specify environment variables that will be visible to the browser. Defaults to `process.env`.
   */
  env?: Object;

  /**
   * **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
   */
  devtools?: boolean;

  /**
   * Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
   */
  slowMo?: number;
}

interface BrowserTypeConnectOptions {
  /**
   * A browser websocket endpoint to connect to. **required**
   */
  wsEndpoint: string;

  /**
   * Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on. Defaults to 0.
   */
  slowMo?: number;
}

interface ElementHandleUncheckOptions {
  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleSetInputFilesOptions {
  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleSetInputFilesFiles {
  /**
   * File name **required**
   */
  name: string;

  /**
   * File type **required**
   */
  type: string;

  /**
   * Base64-encoded data **required**
   */
  data: string;
}

interface ElementHandleSelectOptionOptions {
  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleSelectOptionValues {
  /**
   * Matches by `option.value`.
   */
  value?: string;

  /**
   * Matches by `option.label`.
   */
  label?: string;

  /**
   * Matches by the index.
   */
  index?: number;
}

interface ElementHandleScreenshotOptions {
  /**
   * The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won't be saved to the disk.
   */
  path?: string;

  /**
   * Specify screenshot type, defaults to `png`.
   */
  type?: "png" | "jpeg";

  /**
   * The quality of the image, between 0-100. Not applicable to `png` images.
   */
  quality?: number;

  /**
   * Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.
   */
  omitBackground?: boolean;
}

interface ElementHandlePressOptions {
  /**
   * Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

export interface ElementHandleHoverOptions {
  /**
   * A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
   */
  position?: ElementHandleHoverOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleHoverOptionsPosition {
  x: number;

  y: number;
}

interface ElementHandleFillOptions {
  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

export interface ElementHandleDblclickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
   */
  position?: ElementHandleDblclickOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleDblclickOptionsPosition {
  x: number;

  y: number;
}

export interface ElementHandleClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
   */
  position?: ElementHandleClickOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleClickOptionsPosition {
  x: number;

  y: number;
}

interface ElementHandleCheckOptions {
  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface ElementHandleBoundingBox {
  /**
   * the x coordinate of the element in pixels.
   */
  x: number;

  /**
   * the y coordinate of the element in pixels.
   */
  y: number;

  /**
   * the width of the element in pixels.
   */
  width: number;

  /**
   * the height of the element in pixels.
   */
  height: number;
}

interface FrameWaitForSelectorOptions {
  /**
   * Wait for element to become visible (`visible`), hidden (`hidden`), present in dom (`attached`) or not present in dom (`detached`). Defaults to `attached`.
   */
  waitFor?: "attached" | "detached" | "visible" | "hidden";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameWaitForNavigationOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * URL string, URL regex pattern or predicate receiving URL to match while waiting for the navigation.
   */
  url?: string | RegExp | Function;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
}

interface FrameWaitForLoadStateOptions {
  /**
   * Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameWaitForFunctionOptions {
  /**
   * An interval at which the `pageFunction` is executed, defaults to `raf`. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. If `polling` is a string, then it can be one of the following values:
   *  - `'raf'` - to constantly execute `pageFunction` in `requestAnimationFrame` callback. This is the tightest polling mode which is suitable to observe styling changes.
   *  - `'mutation'` - to execute `pageFunction` on every DOM mutation.
   */
  polling?: number | "raf" | "mutation";

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameWaitForOptions {
  /**
   * Wait for element to become visible (`visible`), hidden (`hidden`), present in dom (`attached`) or not present in dom (`detached`). Defaults to `attached`.
   */
  waitFor?: "attached" | "detached" | "visible" | "hidden";

  /**
   * An interval at which the `pageFunction` is executed, defaults to `raf`. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. If `polling` is a string, then it can be one of the following values:
   *  - `'raf'` - to constantly execute `pageFunction` in `requestAnimationFrame` callback. This is the tightest polling mode which is suitable to observe styling changes.
   *  - `'mutation'` - to execute `pageFunction` on every DOM mutation.
   */
  polling?: number | "raf" | "mutation";

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameUncheckOptions {
  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameSetContentOptions {
  /**
   * Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider setting content to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider setting content to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider setting content to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
}

interface FrameSelectOptionOptions {
  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameSelectOptionValues {
  /**
   * Matches by `option.value`.
   */
  value?: string;

  /**
   * Matches by `option.label`.
   */
  label?: string;

  /**
   * Matches by the index.
   */
  index?: number;
}

interface FramePressOptions {
  /**
   * Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameHoverOptions {
  /**
   * A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
   */
  position?: FrameHoverOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameHoverOptionsPosition {
  x: number;

  y: number;
}

interface FrameGotoOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";

  /**
   * Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().
   */
  referer?: string;
}

interface FrameFocusOptions {
  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameFillOptions {
  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameDblclickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
   */
  position?: FrameDblclickOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameDblclickOptionsPosition {
  x: number;

  y: number;
}

interface FrameClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
   */
  position?: FrameClickOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameClickOptionsPosition {
  x: number;

  y: number;
}

interface FrameCheckOptions {
  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface FrameAddStyleTagOptions {
  /**
   * URL of the `<link>` tag.
   */
  url?: string;

  /**
   * Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw CSS content to be injected into frame.
   */
  content?: string;
}

interface FrameAddScriptTagOptions {
  /**
   * URL of a script to be added.
   */
  url?: string;

  /**
   * Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw JavaScript content to be injected into frame.
   */
  content?: string;

  /**
   * Script type. Use 'module' in order to load a Javascript ES6 module. See script for more details.
   */
  type?: string;
}

interface PageWaitForSelectorOptions {
  /**
   * Wait for element to become visible (`visible`), hidden (`hidden`), present in dom (`attached`) or not present in dom (`detached`). Defaults to `attached`.
   */
  waitFor?: "attached" | "detached" | "visible" | "hidden";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageWaitForResponseOptions {
  /**
   * Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageWaitForRequestOptions {
  /**
   * Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.
   */
  timeout?: number;
}

interface PageWaitForNavigationOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * A glob pattern, regex pattern or predicate receiving URL to match while waiting for the navigation.
   */
  url?: string | RegExp | Function;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
}

interface PageWaitForLoadStateOptions {
  /**
   * Maximum waiting time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageWaitForFunctionOptions {
  /**
   * An interval at which the `pageFunction` is executed, defaults to `raf`. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. If `polling` is a string, then it can be one of the following values:
   *  - `'raf'` - to constantly execute `pageFunction` in `requestAnimationFrame` callback. This is the tightest polling mode which is suitable to observe styling changes.
   *  - `'mutation'` - to execute `pageFunction` on every DOM mutation.
   */
  polling?: number | "raf" | "mutation";

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the page.setDefaultTimeout(timeout) method.
   */
  timeout?: number;
}

interface PageWaitForOptions {
  /**
   * Wait for element to become visible (`visible`), hidden (`hidden`), present in dom (`attached`) or not present in dom (`detached`). Defaults to `attached`.
   */
  waitFor?: "attached" | "detached" | "visible" | "hidden";

  /**
   * An interval at which the `pageFunction` is executed, defaults to `raf`. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. If `polling` is a string, then it can be one of the following values:
   *  - `'raf'` - to constantly execute `pageFunction` in `requestAnimationFrame` callback. This is the tightest polling mode which is suitable to observe styling changes.
   *  - `'mutation'` - to execute `pageFunction` on every DOM mutation.
   */
  polling?: number | "raf" | "mutation";

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageViewportSize {
  /**
   * page width in pixels.
   */
  width: number;

  /**
   * page height in pixels.
   */
  height: number;
}

interface PageUncheckOptions {
  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

export interface PageSetViewportSizeViewportSize {
  /**
   * page width in pixels. **required**
   */
  width: number;

  /**
   * page height in pixels. **required**
   */
  height: number;
}

interface PageSetContentOptions {
  /**
   * Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * When to consider setting markup succeeded, defaults to `load`. Given an array of event strings, setting content is considered to be successful after all events have been fired. Events can be either:
   *  - `'load'` - consider setting content to be finished when the `load` event is fired.
   *  - `'domcontentloaded'` - consider setting content to be finished when the `DOMContentLoaded` event is fired.
   *  - `'networkidle0'` - consider setting content to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider setting content to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
}

interface PageSelectOptionOptions {
  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageSelectOptionValues {
  /**
   * Matches by `option.value`.
   */
  value?: string;

  /**
   * Matches by `option.label`.
   */
  label?: string;

  /**
   * Matches by the index.
   */
  index?: number;
}

interface PageScreenshotOptions {
  /**
   * The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won't be saved to the disk.
   */
  path?: string;

  /**
   * Specify screenshot type, defaults to `png`.
   */
  type?: "png" | "jpeg";

  /**
   * The quality of the image, between 0-100. Not applicable to `png` images.
   */
  quality?: number;

  /**
   * When true, takes a screenshot of the full scrollable page, instead of the currently visibvle viewport. Defaults to `false`.
   */
  fullPage?: boolean;

  /**
   * An object which specifies clipping of the resulting image. Should have the following fields:
   */
  clip?: PageScreenshotOptionsClip;

  /**
   * Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images. Defaults to `false`.
   */
  omitBackground?: boolean;
}

interface PageScreenshotOptionsClip {
  /**
   * x-coordinate of top-left corner of clip area
   */
  x: number;

  /**
   * y-coordinate of top-left corner of clip area
   */
  y: number;

  /**
   * width of clipping area
   */
  width: number;

  /**
   * height of clipping area
   */
  height: number;
}

interface PageReloadOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
}

interface PagePressOptions {
  /**
   * Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PagePdfOptions {
  /**
   * The file path to save the PDF to. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the PDF won't be saved to the disk.
   */
  path?: string;

  /**
   * Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
   */
  scale?: number;

  /**
   * Display header and footer. Defaults to `false`.
   */
  displayHeaderFooter?: boolean;

  /**
   * HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them:
   *  - `'date'` formatted print date
   *  - `'title'` document title
   *  - `'url'` document location
   *  - `'pageNumber'` current page number
   *  - `'totalPages'` total pages in the document
   */
  headerTemplate?: string;

  /**
   * HTML template for the print footer. Should use the same format as the `headerTemplate`.
   */
  footerTemplate?: string;

  /**
   * Print background graphics. Defaults to `false`.
   */
  printBackground?: boolean;

  /**
   * Paper orientation. Defaults to `false`.
   */
  landscape?: boolean;

  /**
   * Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages.
   */
  pageRanges?: string;

  /**
   * Paper format. If set, takes priority over `width` or `height` options. Defaults to 'Letter'.
   */
  format?: string;

  /**
   * Paper width, accepts values labeled with units.
   */
  width?: string | number;

  /**
   * Paper height, accepts values labeled with units.
   */
  height?: string | number;

  /**
   * Paper margins, defaults to none.
   */
  margin?: PagePdfOptionsMargin;

  /**
   * Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format` options. Defaults to `false`, which will scale the content to fit the paper size.
   */
  preferCSSPageSize?: boolean;
}

interface PagePdfOptionsMargin {
  /**
   * Top margin, accepts values labeled with units. Defaults to `0`.
   */
  top?: string | number;

  /**
   * Right margin, accepts values labeled with units. Defaults to `0`.
   */
  right?: string | number;

  /**
   * Bottom margin, accepts values labeled with units. Defaults to `0`.
   */
  bottom?: string | number;

  /**
   * Left margin, accepts values labeled with units. Defaults to `0`.
   */
  left?: string | number;
}

interface PageHoverOptions {
  /**
   * A point to hover relative to the top-left corner of element padding box. If not specified, hovers over some visible point of the element.
   */
  position?: PageHoverOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the hover, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageHoverOptionsPosition {
  x: number;

  y: number;
}

interface PageGotoOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";

  /**
   * Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().
   */
  referer?: string;
}

interface PageGoForwardOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
}

interface PageGoBackOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultNavigationTimeout(timeout), browserContext.setDefaultTimeout(timeout), page.setDefaultNavigationTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Events can be either:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   */
  waitUntil?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
}

interface PageFrameOptions {
  /**
   * frame name specified in the `iframe`'s `name` attribute
   */
  name?: string;

  /**
   * A glob pattern, regex pattern or predicate receiving frame's `url` as a URL object.
   */
  url?: string | RegExp | Function;
}

interface PageFocusOptions {
  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageFillOptions {
  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageEmulateMediaOptions {
  /**
   * Changes the CSS media type of the page. The only allowed values are `'screen'`, `'print'` and `null`. Passing `null` disables CSS media emulation.
   */
  media?: "screen" | "print";

  /**
   * Emulates `'prefers-colors-scheme'` media feature, supported values are `'light'`, `'dark'`, `'no-preference'`.
   */
  colorScheme?: "dark" | "light" | "no-preference";
}

export interface PageDblclickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * A point to double click relative to the top-left corner of element padding box. If not specified, double clicks to some visible point of the element.
   */
  position?: PageDblclickOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the double click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageDblclickOptionsPosition {
  x: number;

  y: number;
}

interface PageCloseOptions {
  /**
   * Defaults to `false`. Whether to run the
   * before unload
   * page handlers.
   */
  runBeforeUnload?: boolean;
}

export interface PageClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left" | "right" | "middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;

  /**
   * A point to click relative to the top-left corner of element padding box. If not specified, clicks to some visible point of the element.
   */
  position?: PageClickOptionsPosition;

  /**
   * Modifier keys to press. Ensures that only these modifiers are pressed during the click, and then restores current modifiers back. If not specified, currently pressed modifiers are used.
   */
  modifiers?: Array<"Alt" | "Control" | "Meta" | "Shift">;

  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageClickOptionsPosition {
  x: number;

  y: number;
}

interface PageCheckOptions {
  /**
   * Whether to bypass the actionability checks. By default actions wait until the element is:
   *  - displayed (for example, no `display:none`),
   *  - is not moving (for example, waits until css transition finishes),
   *  - receives pointer events at the action point (for example, waits until element becomes non-obscured by other elements).
   *  - Even if the action is forced, it will wait for the element matching selector to be in DOM. Defaults to `false`.
   */
  force?: boolean;

  /**
   * Actions that cause navigations are waiting for those navigations to fire `domcontentloaded` by default. This behavior can be changed to either wait for another load phase or to omit the waiting altogether using `nowait`:
   *  - `'domcontentloaded'` - consider navigation to be finished when the `DOMContentLoaded` event is fired.
   *  - `'load'` - consider navigation to be finished when the `load` event is fired.
   *  - `'networkidle0'` - consider navigation to be finished when there are no more than 0 network connections for at least `500` ms.
   *  - `'networkidle2'` - consider navigation to be finished when there are no more than 2 network connections for at least `500` ms.
   *  - `'nowait'` - do not wait.
   */
  waitUntil?:
    | "load"
    | "domcontentloaded"
    | "networkidle0"
    | "networkidle2"
    | "nowait";

  /**
   * Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the browserContext.setDefaultTimeout(timeout) or page.setDefaultTimeout(timeout) methods.
   */
  timeout?: number;
}

interface PageAddStyleTagOptions {
  /**
   * URL of the `<link>` tag.
   */
  url?: string;

  /**
   * Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw CSS content to be injected into frame.
   */
  content?: string;
}

interface PageAddScriptTagOptions {
  /**
   * URL of a script to be added.
   */
  url?: string;

  /**
   * Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw JavaScript content to be injected into frame.
   */
  content?: string;

  /**
   * Script type. Use 'module' in order to load a Javascript ES6 module. See script for more details.
   */
  type?: string;
}

interface PageAddInitScriptScript {
  /**
   * Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw script content.
   */
  content?: string;
}

interface PageFilechooserPayload {
  /**
   * handle to the input element that was clicked
   */
  element?: ElementHandle;

  /**
   * Whether file chooser allow for multiple file selection.
   */
  multiple?: boolean;
}
